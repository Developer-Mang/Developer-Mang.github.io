{"pages":[],"posts":[{"title":"My blog start","text":"Dev.Mang의 블로그 제작 시작","link":"/2020/02/20/My-blog-start/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/02/20/hello-world/"},{"title":"let, const와 블록 레벨 스코프","text":"var 키워드로 선언한 변수의 문제점자바스크립트의 변수 선언 키워드 var 를 사용하면 많은 문제점이 생긴다. 변수의 중복 선언 허용var 로 생성한 변수는 중복 선언을 허용한다. 이것은 먼저 선언된 변수 값이 의도치 않게 변경될 수 있는 가능성이 있다는 것이다. 함수 레벨 스코프var 로 생성한 변수는 함수 블록 만을 지역 스코프로 인정한다. 따라서 함수 외부에서 var로 선언한 변수는 전역 변수가 된다. 변수 호이스팅var 로 생성한 변수는 변수 호이스팅이 일어난다. 선언하는 코드 이전에 이미 선언되어 참조될 수 있고 이것으로 오류를 발생시킬 가능성이 높아진다. let 키워드와 const 키워드(ES6)var로 선언한 변수는 위와 같은 문제를 갖고 있기 때문에 이를 해결하기 위해서 let과 const 키워드를 지원한다. letlet으로 선언한 변수는 다음과 같은 특징을 갖는다. 변수의 중복 선언을 금지 블록 레벨 스코프 지원 변수 호이스팅에 대한 에러 코드 지원변수 호이스팅이 안 일어나지는 않는다. 다만 초기화 단계와 선언단계가 분리되있고 초기화 전에 변수를 참조하려고 하면 참조 에러(ReferenceError)가 발생한다. 선언단계서 부터 초기화 단계가 되기 전까지를 일시적 사각지대라고 한다. 브라우저 환경에서 전역 변수로 선언할 시 전역 객체인 window의 프로퍼티로 등록되지 않는다. constconst로 선언한 변수는 상수를 선언하기 위해서 사용한다. const로 선언한 변수는 반드시 선언과 동시에 할당이 이루어져야 한다.또한, 그렇게 선언된 const로 선언한 변수는 재할당이 시스템적으로 금지된다. ES6 이상의 버전을 사용한다면 변수 선언에 가급적 const를 사용하며, 변경할 필요가 있는 변수의 경우 let을 사용하는 것을 권장한다.또한, let으로 선언한 변수의 스코프는 최대한 좁게 만드는 것을 권장한다.","link":"/2020/02/27/let-const%EC%99%80-%EB%B8%94%EB%A1%9D-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84/"},{"title":"ES6 함수의 추가 기능","text":"함수의 구분ES6에서 사용목적에 따라 함수 구분한다. 일반 함수 메소드 화살표 함수 일반 함수ES6이전에 사용하던 함수 선언문이나 함수 표현식으로 정의된 함수이다.ES6에서 오직 이 일반 함수만이 constructor 함수임으로 일반 함수만 new 연산자로 호출할 수 있다. 메소드ES6에서는 메소드 축약 표현으로 정의된 함수만을 메소드로 취급한다.그리고 이렇게 정의된 메소드만 메소드가 바인딩된 객체를 가르키는 내부슬롯 [[HomeObject]]을 갖는다. 따라서 super 키워드는 이 메소드만 사용 가능하다. 화살표 함수function 키워드 대신에 화살표(=&gt;)를 사용하여 정의한 함수이다.(매개 변수들…) =&gt; {함수 몸체} 로 이루어진다.화살표 함수는 다음과 같은 특징을 갖는다. 매개 변수매개 변수가 한개인 경우에만 ()를 생략 가능하다.오직 매개 변수가 한개인 경우만 생략 가능하다. 없으면 써주어야한다.또한, 일반함수와 다르게 중복된 매개변수를 사용할 수 없다. 함수 몸체함수 몸체가 한 줄의 문으로 구성되면 {}를 생략하고 바로 사용 가능하며 해당 문을 반환한다.한줄이 아닌 경우에는 생략할 수 없고, 반환값이 있다면 명시적으로 반환해야한다.객체 리터럴만을 반환하는 경우 {}를 생략하고 ({반환할 객체 리터럴})의 형식으로 사용가능하다. this, arguments, super, new.target 바인딩을 갖지 않는다. this화살표 함수 내에서 this를 참조하면 상위 컨텍스트의 this를 참조하게 된다.this 바인딩을 갖지 않기 때문에, Function.prototype.apply/call/bind로 this 바인딩해줄 수 없다. super/ argumentsthis와 마찬가지로 바인딩 되어있지 않기에 참조시 상위 컨텍스트의 super/arguments를 참조한다. Rest 파라미터매개 변수 이름 앞에 …를 붙여서 정의한 매개 변수이다. 전달받은 인수들을 배열로 전달 받는다.*Rest 파라미터가 있음으로 arguments 객체를 배열로 변환하는 번거로움을 피할 수 있다. 매개변수의 기본값일반적으로 매개 변수를 정의하고 따로 초기화을 하지 않으면 undefined 값으로 초기화된다.하지만 ES6에서 매개변수에 바로 할당문을 사용함으로서 초기화를 간소화 할 수 있다.","link":"/2020/03/20/ES6-%ED%95%A8%EC%88%98%EC%9D%98-%EC%B6%94%EA%B0%80-%EA%B8%B0%EB%8A%A5/"},{"title":"빌트인 객체","text":"자바스크립트 객체의 분류 표준 빌트인 객체ECMAScript 사양에 정의된 객체를 말한다. 어플리케이션 전역의 공통 기능을 말한다. 빌트인 객체는 전역 객체의 프로퍼티로 제공된다. 호스트 객체ECMAScript 사양에 정의되어 있지 않는 자바스크립트 환경(브라우저 환경 또는 Node.js 환경)에서 추가적으로 제공하는 객체를 말한다. 사용자 정의 객체사용자가 집접 정의한 객체를 말한다. 표준 빌트인 객체자바스크립트는 40여개의 표준 빌트인 객체를 제공한다.표준 빌트인 객체에는 인스턴스를 생성할 수 있는 생성자 함수 객체와 아닌 객체가 있는데, 아닌 객체에는 Math, Reflect, JSON 이 있다.생성자 함수 객체는 프로토타입 메소드와 정적 메소드를 제공하지만 아닌 객체는 정적 메소드만 제공한다.즉, 생성자 함수인 빌트인 객체로 인스턴스를 만들면 생성자 함수의 prototype 프로퍼티의 값이 해당 인스턴스의 프로토타입에 바인딩된다.따라서 해당 인스턴스는 바인딩된 프로토타입 객체의 다양한 기능을 사용가능하다. 원시값과 레퍼 객체문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 말한다.마침표 표기법으로 접근시 그 순간 일시적으로 레퍼객체를 만들어 접근한 후에 바로 원시값으로 되돌아간다.레퍼객체는 원시값을 객체로 만들어 메소드를 상속 받을 수 있게 만드는 것이다. 전역 객체코드가 실행되기 이전 단계에서 자바스크립트 엔진에 의해 어떤 객체보다 먼저 생성되는 특수한 객체이며 어떤 객체에도 속하지 않은 최상위 객체이다.실행 환경에 따라 브라우저에서는 window, Node.js 에서는 global 이 전역 객체를 지칭한다. 전역객체는 다음과 같은 프로퍼티를 갖는다. 표준 빌트인 객체 호스트 객체 var 키워드로 선언된 전역 변수 let, const로 선언된 변수는 포함되지 않는다. 전역 함수 전역 객체의 프로퍼티를 참조할 때, window.(또는 global.)을 생략할 수 있다. 빌트인 전역 프로퍼티 Infinity양/음 무한대를 나타내는 숫자값 Infinity를 갖는다. NaN숫자가 아닌 숫자 값 NaN을 갖는다. undefined원시타입 undefined 값을 갖는다. 빌트인 전역 함수어플리케인 전역에서 호출할 수 있는 전역 객체의 메소드이다. evel문자열 형태로 매개변수에 전달된 코드를 런타임에 동적으로 평가하고 실행한 결과값을 반환하며 해당 코드가 여러 문으로 이루어져있으면 모든 코드를 실행하고 마지막 문의 결과값을 반환한다.evel 함수는 호출될 시 동적으로 스코프를 수정한다. 즉 호출된 스코프 외에 영향을 주지 않는다.엄격모드에서는 독자적인 스코프를 생성한다. isFinite매개 변수에 전달된 값이 정상적인 유한수인지 검사하여 그 결과를 불리언 타입으로 반환한다.유한수란? 숫자 타입으로 암묵적 타입 변환을 했을 시 유효한 숫자 원시값으로 변화되는 값을 말한다. isNaN매개 변수에 전달된 값이 NaN인지 검사하여 그 결과를 불리언 타입으로 반환한다. parseFloat매개 변수에 전달된 문자열을 부동소수점 숫자로 변환하여 반환한다.공백으로 구분된 문자열을 첫번째 문자열만 변환한다. 만약 첫번째 문자열을 숫자로 변환할 수 없으면 NaN값을 반환한다.전후 공백은 무시된다. parseInt매개 변수에 전달된 문자열을 정수형 숫자로 해석하여 반환한다.첫번째 매개 변수에 진수 리터럴을 전달할 수 있는데 16진수 리터럴(0x)는 해석하지만 2진수 리터럴(0b), 8진수 리터럴(0o)은 제대로 해석하지 못한다.첫번째 매개 변수에 전달된 문자열의 첫번째 문자가 해당 지수의 숫자로 변환되지 못하면 NaN값을 반환한다. 첫 문자만 변환할 수 있으면 그 다음에 변환되지 못하는 문자는 무시하고 변환하여 반환한다.두번째 매개 변수에 진법을 나타내는 수를 지정할 수 있다. 지정하지 않으면 10진수 정수로 반환한다. encodeURI/decodeURIencodeURI는 매개 변수로 전달된 URI를 인코딩하며,decodeURI는 매개 변수로 전달된 인코딩된 URI를 디코딩한다.인코딩이란? 네트워크를 통해 정보를 공유할 떄 어떤 시스템도 읽을 수 있는 아스키 문자 셋(ASCII Character-set)으로 변환하는 것이다.디코딩은 인코딩의 반대 개념으로 아스키 문자 셋을 URI로 변환하는 것이다. encodeURIComponent/decodeURIComponentencodeURIComponent는 매개 변수로 전달된 URI 구성 요소를 인코딩하며,decodeURIComponent는 매개 변수로 전달된 인코딩 된 URI 구성 요소를 디코딩한다.쿼리 파라미터 구분자인 =, ?, &amp;도 인코딩하고 디코딩한다. 암묵적 전역선언하지 않은 식별자에 값을 할당할 때 전역 객체의 프로퍼티처럼 되어 마치 전역 변수처럼 동작하는 현상을 암묵적 전역이라고 한다.전역 변수는 delete연산자로 삭제할 수 없지만 암묵적 전역으로 사용된 식별자는 프로퍼티이기 때문에 삭제가 가능하다.","link":"/2020/03/10/%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EA%B0%9D%EC%B2%B4/"},{"title":"객체 리터럴","text":"객체란?키(key)와 값(value)로 구성된 프로퍼티(Property)의 집합.원시 타입 값과 달리 변경가능한 값이다. 객체 생성 방법 객체 리터럴{…} 안에 0개 이상의 프로퍼티를 정의. ex) var obj = {name:'객체',sayFunc(){}}; 객체 리터럴 중괄호는 블록문을 나타내는 것이 아니기 때문에 문 끝에 ;을 붙여주어야한다. Object 생성자 함수 생성자 함수 Object.create 메소드 클래스(ES6) 프로퍼티란?객체의 상태나 동작을 나타내는 값.키(key)와 값(value)로 구성된 객체 안에 단위이다. ,(쉼표)로 구분한다.동일한 key의 프로퍼티를 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다. 키(key)프로퍼티 값에 접근하는 식별자 같은 일을 한다. []안에 평가식을 사용해 평가된 값을 키로 동적으로 생성가능하다. 식별자 네이밍 규칙을 따르지 않는 이름을 사용가능하다. 단,’첫글자에 숫자가 오지 말것!’이라는 규칙을 제외한 다른 이름은 ‘…’로 묶어주어야 한다.빈 문자열을 이름으로 사용 가능하다. 하지만 의미을 갖을 수 없음으로 권장하지 않는다.문자열과 symbol 타입 이외의 값을 사용하면 암묵적으로 문자열 타입 값으로 변환한다. 값(value)해당 프로퍼티를 참조할 시 참조되는 값. 모든 표현식은 사용가능하다.단 함수를 프로퍼티에 값으로 사용할 경우, 함수와 구별을 위해 메소드(Method)라 부른다. 메소드(Method)프로퍼티 값에 함수를 사용하면 함수 객체와 구별하기 위해 메소드라고 부름. 프로퍼티 접근 방법 마침표 표기법해당 객체가 할당된 변수 명 뒤에 .(마침표)를 찍고 객체 안에 있는 키 이름를 뒤에 붙인다. 대괄호 표기법해당 객체가 할당된 변수 명 뒤에 [] 붙이고 안에 문자열로 키 이름을 넣는다.식별자 네이밍 규칙을 따르지 않은 프로퍼티에 접근하기 위해서는 반드시 대괄호 표기법으로 접근해야한다. ex) var obj = {key:value}; // 마침표 표기법 obj.key // -> value // 대괄호 표기법 obj['key'] // -> value 객체에 존재하지 않는 프로퍼티에 접근하면 undefined 값을 반환한다.객체에 존재하지 않는 프로퍼티에 값을 할당하면 동적으로 프로퍼티를 해당 객체에 추가한다. 프로퍼티 삭제delete 연산자를 사용하면 해당 프로퍼티를 삭제 가능하다. 존재하지 않는 프로퍼티를 삭제하려고 하면 에러 없이 무시된다. 객체 리터럴 확장 기능 프로퍼티 축약 표현(ES6)프로퍼티 값에 변수를 사용하는 경우, 변수 명과 key의 이름이 같을 경우 키를 생략할 수 있다. 프로퍼티 키 동적 생성(ES5)객체 리터럴 외부에서 대괄호 표기법을 사용해서 […] 안에 표현식을 사용해서 동적으로 프로퍼티 키 이름과 값을 추가할 수 있다. 문자열 탬플릿을 사용하면 더 가독성 좋게 만들수 있다. 메소드 축약 표현메소드를 추가할 때 function 키워드를 생략할 수 있다. 단, 프로퍼티 값으로 함수를 할당한 것과 다르게 동작한다.","link":"/2020/02/24/%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4/"},{"title":"this","text":"this 키워드자신이 속한 객체 또는 생성할 인스턴스를 가르키는 자기 참조 변수이다.this는 함수 호출 방식에 따라 가르키는 것이 동적으로 결정된다. 함수 호출 방식과 this 바인딩함수를 호출하는 방식에 따라 this가 바인딩되는 것이 달라짐으로 함수를 호출하는 방법부터 알아보자 일반 함수 호출선언된 함수를 호출 연산자로 호출한다.이때, this는 전역 객체가 바인딩된다. 중첩함수든 콜백함수든 일반 함수로 호출하면 this에는 전역 객체가 바인딩된다. 메소드 호출‘호출하는 객체’.’메소드 이름’ 형식으로 호출한다.이때, this는 호출 하는 객체가 바인딩된다. 생성자 함수 호출new 연산자를 사용해서 호출한다.이때, this는 생성되는 인스턴스에 바인딩된다. Function.prototype.apply/call/bindapply와 call은 함수 호출을 하는 메소드이다. apply/call(this바인딩할 객체[, 인수들…]) 형식으로 사용하며,전달한 this 객체를 this 바인딩하며, bind는 함수를 호출 하지 않고 전달한 this 객체를 바인딩만 시킴으로 호출할 시 해당 함수와 this 객체가 this 바인딩된다.","link":"/2020/03/10/this/"},{"title":"배열","text":"배열여러 개의 값을 순차적으로 나열한 자료 구조이다. 주로 관계가 있는 여러 개의 값을 묶어두는 데 사용한다. 요소배열이 갖고 있는 값. 인덱스배열의 요소가 자신의 위치를 나타내는 0 이상의 정수. 인덱스로 값을 찾는다. length배열의 길이를 나타낸다.length는 반드시 배열 요소의 갯수를 나타내는 것이 아니다. 자바스크립트와 다르게 다른 언어는 요소들의 타입을 동일하게 맞추어주어야 하지만 자바스크립트는 요소들의 타입이 달라도 된다.동일한 타입의 요소를 갖고 시작 메모리 주소를 통해 빈틈없이 연속적으로 메모리에 요소들이 저장되있는 배열을 밀집 배열이라 하며,자바스크립트처럼 연속적으로 메모리에 저장되있지 않은 배열을 희소 배열이라 한다. 밀집 배열과 희소 배열밀집 배열은 연산을 통한 정렬된 특정 요소의 접근을 효율적으로 할수 있지만, 배열에 요소를 삽입이나 삭제를 해야하는 경우 삽입이나 삭제한 메모리 이후의 요소들을 전부 이동시켜야하는 단점이 있다. 희소 배열은 밀집 배열의 장단점이 반대이다. 자바스크립트와 배열사실 자바스크립트는 인덱스를 프로퍼티 키로 갖으며, length 프로퍼티를 갖고, Array.prototype 메소드를 사용할 수 있는 객체이다.따라서, length에 값을 할당할 수 있고, 그 값은 배열의 요소의 수보다 작거나 클수 있다. length 값이 배열 요소들의 수보다 작으면 배열의 길이가 작아진다. 그 이상의 요소들을 순회할 수 없다는 뜻이다. length 값이 배열 요소들의 수보다 클 때는 배열의 길이가 늘어나지는 않는다. 실제 배열에는 아무런 변화가 없고 단지 length 값이 바뀔 뿐이다. 또한 자바스크립트는 비어있는 요소를 넣을 수 있다. 이를 희소 배열이라고 한다. 배열 생성 배열 리터럴0개 이상의 요소를 쉼표로 구분하여 [ ] 로 묶어준다. Array 생성자 함수배열을 생성하는 생성자 함수이다. 전달해준 인수의 갯수에 따라 생성하는 배열이 다르다. 생략/0빈 배열을 생성한다. 1개해당 인수를 배열의 길이로 갖는 빈 배열을 생성한다. 2개 이상해당 인수를 배열의 요소로 갖는 배열을 생성한다. Array.of전달된 인수를 요소로 갖는 배열을 생성한다. Array.from전달된 유사 배열 객체 또는 이터러블 객체를 분해하여 각각의 값을 요소로 갖는 배열을 생성한다.유사 배열 객체란? 객체지만 배열처럼 인덱스를 키로 갖고 length 프로퍼티를 갖는 객체를 말한다.이터러블 객체란? 유사 배열 객체처럼 length 프로퍼티를 갖고 순회할 수 있는 객체를 말한다. 배열 요소 참조/추가/갱신/삭제 참조시에 대괄호 표기법을 사용한다. 대괄호 안에는 인덱스가 와야한다. 추가 및 갱신은 해당 배열의 길이와 같은 숫자의 인덱스 번호를 대괄호 표기법으로 참조하고 값을 할당하면 추가할 수 있다. 배열의 길이보다 큰 수의 인덱스 번호로 추가하면 희소 배열이 된다. 삭제는 프로퍼티 삭제처럼 delete 연산자를 통해 삭제할 수 있지만 해당 인덱스가 통채로 삭제되며 length 값도 변하지 않는다.따라서, Array.prototype.splice 메소드를 사용해서 삭제해야한다. 배열 메소드 Array.isArray주어진 인수가 배열이면 true, 아니면 false를 반환. Array.prototype.indexOf인수로 전달된 인수를 검색, 해당 요소의 인덱스를 반환.중복 요소일 경우, 첫번째 인덱스 반환요소가 없을 때, -1를 반환 Array.prototype.push전달한 인수를 원본 배열의 마지막 요소로 추가. 그 후 변경된 length 값을 반환.원본 배열을 바꿈 Array.prototype.pop원본 배열의 마지막 요소를 제거. 제거한 요소를 반환.원본 배열을 바꿈원본 배열이 빈 배열이면 undefined를 반환 Array.prototype.unshift전달한 인수를 원본 배열에 선두에 추가. 변경된 length 값을 반환.원본 배열을 바꿈 Array.prototype.shift원본 배열의 선두 요소를 제거. 제거한 요소를 반환.원본 배열을 바꿈원본 배열이 빈 배열이면 undefined를 반환 Array.prototype.concat전달한 인수를 원본 배열의 마지막 요소로 추가. 그 후 해당 배열을 반환.push와 차이는 인수에 배열이 있으면 분해해서 넣으며 원본 배열을 바꾸지 않는다는 점에 있다. push/unshif 메소드와 concat 메소드를 사용하는 대신 ES6의 스프레드 문법을 일관성 있게 사용하는 것을 추천 Array.prototype.splice원본 배열의 중간에 요소를 추가/제거. 해당 배열을 반환원본 배열을 바꿈3개의 인수를 가질 수 있다. 순서대로 start : 본 배열의 요소를 제거하기 시작할 인덱스. 음수일 경우, 배열 끝에서 부터의 인덱스를 나타냄start만 있을 경우, 그 이후의 인덱스를 전부 제거 deleteCount(옵션) : start 인덱스로 부터 제거할 인덱스 수. 생략할 경우 0 items(옵션) : 제거한 위치에 삽입될 요소 목록 Array.prototype.slice인수로 전달한 범위의 요소를 복사. 복사한 배열을 반환2개의 인수를 가질 수 있다. 순서대로 start : 복사 시작할 인덱스. 음수일 경우, 배열 끝에서 부터의 인덱스를 나타냄 end(옵션) : 복사 종료할 인덱스. 생략할 경우 배열 끝까지 복사 Array.prototype.join배열의 모든 요소를 문자열로 반환한 후 인수로 전달한 값을 구분자로서 연결하여 반환. 구분자는 생략 가능하며 기본 구분자는 ‘,’ 이다. Array.prototype.reverse원본 배열의 순서를 반대로 변경. 그 배열을 반환. Array.prototype.fill(ES6)전달한 인수로 일정 부분의 배열을 전부 바꾸어 채움. 해당 배열을 반환.2개의 인수를 가질 수 있다. 순서대로 value : 채울 값 start(옵션) : 채우기 시작할 인덱스. 음수일 경우, 배열 끝에서 부터의 인덱스를 나타냄 end(옵션) : 채우기 종료할 인덱스 Array.prototype.includes(ES7)배열 내에 특정 요소가 포함 되어있는지 검색. 있으면 true, 없으면 false.2개의 인수를 가질 수 있다. 순서대로 value : 검색할 요소 start(옵션) : 검색 시작할 인덱스. 음수 값일 경우, length에서 해당 값을 더한 인덱스부터 검색. 생략할 경우 0 end(옵션) : 검색 종료할 인덱스. 생략할 경우 끝까지 Array.prototype.flat(ES10)배열 내에 배열이 있을 경우 내부에 있는 배열을 푼 배열을 반환. 인수로 전달한 숫자 값 만큼 반복한다. 인수로 Infinity 값을 전달하면 배열 속에 모든 배열을 푼 배열을 반환한다. 배열 고차 함수 Array.prototype.sort정렬 순서를 정의하는 비교함수를 인수로 받아 원본 배열을 해당 규칙에 따라 오름차순으로 정렬한다. 그리고 정렬된 배열을 반환한다.원본 배열을 바꿈숫자의 경우, 문자열 Unicode 코드 포인트 순서에 따라 정렬한다. ex) 1 &lt; 10 &lt; 11 &lt; 2 Array.prototype.forEach배열을 순회하며 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행. undefined를 반환.콜백함수로 전달할 인수로는 순서대로 요소 값 인덱스 this 값 : forEach를 호출한 배열 객체 대부분의 for문을 대체 가능. 하지만 continue 문이나 break 문을 사용할 수 없다. Array.prototype.map배열을 순회하며 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행. 실행되어 반환된 반환값들의 새로운 배열을 반환.콜백함수로 전달할 인수로는 순서대로 요소 값 인덱스 this 값 : map을 호출한 배열 객체 반환된 배열과 원본 배열의 length 값은 반드시 같다 Array.prototype.filter배열을 순회하며 배열의 각 요소에 대하여 인수로 전달된 콜백 함수의 실행 값이 true인 배열의 요소만 추출하여 새로운 배열을 반환.콜백함수로 전달할 인수로는 순서대로 요소 값 인덱스 this 값 : map을 호출한 배열 객체 반환된 배열의 length 값은 반드시 원본 배열의 length 값보다 작거나 같다. Array.prototype.reduce배열을 순회하며 콜백 함수의 이전 반환값과 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 하나의 결과값을 반환.reduce 메소드는 2개의 인수를 받을 수 있는데 첫번째 인수로 콜백 함수, 두번째 인수로 초기값을 받는다.콜백함수로 전달할 인수로는 순서대로 초기 값 요소 값 인덱스 this 값 : reduce를 호출할 배열 객체 사용법 평균 최대값 Math.max 메소드 사용 권장 중복 요소 갯수 중첩 배열 평탄화 Array.prototype.flat 메소드 사용 권장 중복 요소 제거 Array.prototype.filter 메소드 사용 권장 Array.prototype.some배열을 순회하며 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 그 결과가 하나라도 참이라면 true, 모두 거짓이라면 false를 반환.콜백함수로 전달할 인수로는 순서대로 초기 값 요소 값 인덱스 this 값 : reduce를 호출할 배열 객체 Array.prototype.every배열을 순회하며 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 그 결과가 모두 참이라면 true, 하나라도 거짓이라면 false를 반환.콜백함수로 전달할 인수로는 순서대로 초기 값 요소 값 인덱스 this 값 : reduce를 호출할 배열 객체 Array.prototype.find(ES6)배열을 순회하며 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 그 결과가 참인 첫번째 요소를 반환. 참인 요소가 없으면 undefined 값을 반환.콜백함수로 전달할 인수로는 순서대로 초기 값 요소 값 인덱스 this 값 : reduce를 호출할 배열 객체 Array.prototype.findIndex(ES6)배열을 순회하며 각 요소에 대하여 인수로 전달된 콜백 함수를 실행하여 그 결과가 참인 첫번째 요소의 인덱스를 반환. 참인 요소가 없으면 -1을 반환.콜백함수로 전달할 인수로는 순서대로 초기 값 요소 값 인덱스 this 값 : reduce를 호출할 배열 객체 Array.prototype.flatMap(ES10)map을 통해 생성된 새로운 배열을 평탄화. map 메소드와 flat 메소드를 순차적으로 실행하는 효과. 단 평탄화의 깊이는 1이다.","link":"/2020/03/20/%EB%B0%B0%EC%97%B4/"},{"title":"데이터 타입","text":"1. 타입의 종류데이터 타입에는원시 타입 : 숫자, 문자열, 불리언, undefined, null, Symbol객체 타입 : 객체, 함수, 배열 등이 있다. 숫자 : 64비트의 부동소수점 형식. 모든 수를 실수로 처리 문자열 : 16비트 유니코드 문자 집합 형식템플릿 리터럴 : 편리한 문자열 처리기능을 제공 불리언 : 논리적 결과를 나타냄. true/false 만 있음. undefined : 명확한 값이 들어있지 않은 변수에 들어있는 값. null : 변수 안에 값이 없다는 것을 알려주는 값.이전에 참조하던 값을 더이상 참조하지 않겠다! Symbol : 수시로 변하는 객체에 유일한 프로퍼티 키를 주어서 제어하기 위해 사용되는 Symbol 타입 객체를 명시하는 타입 값. 객체 : 위에 있는 원시 타입 값과 다르게 변할 수 있는 값? 템플릿 리터털 멀티라인 문자열 : 줄바꿈을 별도의 코드를 사용하지 않고 표현가능하다. 표현식 삽입 : 표현식이 평가된 값을 문자열로 보여준다. 테그드 템플릿 : 함수에 넣을 프로퍼티를 쉽게 넣을 수 있다. 2. 타입의 필요성 모든 값은 메모리에 저장 및 참조 가능해야 하기 때문에 값에 할당할 크기를 알아야한다. 메모리에 2진수로 저장되는데 참조할 때 어떻게 해석하느냐에 따라 결과가 달라지기 때문이다. 3. 동적 타입 언어와 정적 타입 언어 동적 타입 언어 : 자바스크립트처럼 변수를 선언할 때 타입 값을 지정하지 않아 상황에 따라 타입을 바꿀 수 있는 언어 정적 타입 언어 : c 언어 처럼 변수를 선언할 때 타입을 같이 지정해야하는 언어 동적 타입 언어즉, 변수 선언 단계에서 타입이 결정되는 것이 아니라 변수에 재할당 된 값에 따라 변수의 타입이 결정된다. 값이 확정으로 할당되기 전까지 타입을 확신할 수 없다. 따라서 주의 사항이 생긴다. 1. 필요한 경우 제한적으로 사용할 것. 2. 변수 유효범위(스코프)를 최대한 좁게 설정할 것. 3. 전역변수는 최대한 피할 것. 4. 상수를 애용할 것. 5. 변수 이름을 시멘틱하게 만들 것.","link":"/2020/02/20/%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85/"},{"title":"생성자 함수에 의한 객체 생성","text":"객체를 생성하는 방법은 객체 리터럴 외에도 다양한 방법으로 생성할 수 있다. Object 생성자 함수new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 반환한다. 그후에 이 빈 객체에 프로퍼티 또는 메소드를 추가하여 객체를 완성할 수 있다. 생성자 함수란?new 연산자와 함께 호출하여 객체를 반환하는 함수를 말한다. 이 때 함수는 일반적인 함수가 올수 있다.이렇게 생성자 함수로 생성된 객체는 인스턴스라 하며 일반 객체 리터럴로 생성한 객체와는 차이가 있다.new 연산자와 함께 사용하지 않으면 생성자 함수가 아닌 그냥 함수 취급되고 동작한다.일반 함수와 구별하기 위해서 파스칼 케이스로 명명한다. 자바스크립트는 Object, String, Number, Boolean, Function, Array, Date, RegExp 등의 객체를 생성하는 빌트인 함수를 제공한다. 객체 리터럴로 만든 객체의 문제점객체 리터럴 ‘{}’로 만든 객체는 직관적이고 간편하지만 가장 큰 문제가 있다.하나의 객체 리터럴은 하나의 객체만을 만든다.이는, 동일한 프로퍼티를 갖는 객체를 생성할 때 매번 같은 코드를 새로 기술해야 하기 때문에 비효율적이다. 생성자 함수로 만든 객체의 장점 동일한 프로퍼티를 갖는 객체를 여러개 만들 수 있다. this 가르키는 값, this 바인딩이 다르다.객체 리터럴로 만든 객체는 this가 전역 객체를 가르킨다. 하지만 생성자 함수로 만든 객체는 만들어진 인스턴스를 가르킨다. 내부 메소드모든 객체는 내부 슬롯과 내부 메소드를 지원한다. 즉 함수든 배열이든 프로퍼티와 메소드를 갖을 수 있다는 말이다. callable내부 메소드 .Call()을 갖는 함수 객체. 호출 가능한 함수를 말한다. 당연히 모든 함수는 호출 가능하니 모든 함수는 callable이다. constructor와 non-constructor.Construct() 메소드를 갖거나/갖지 않는 함수 객체. 생성자 함수로써 호출 가능한 객체를 말한다. 이것은 모든 함수는 안되고 해당 메소드가 있어야 생성자 함수로 호출 가능하다는 것을 말한다.자바스크립트 엔진이 내부 동작을 하면서 함수 정의가 평가될 때 FunctionCreate라는 기능을 사용하는데 그 때 정의 방식에 따라 함수의 종류를 나타내는 문자열을 인수로 받는다. 그때 함수의 종류가 Normal일 때만 constructor로 인식한다. 인스턴스 생성 과정생성자 함수를 호출하면 인스턴스를 생성하면서 해당 인스턴스를 초기화한다. 이 과정은 자바스크립트 엔진이 암묵적 처리를 통해 생성하고 반환한다.그리고 이렇게 만들어진 인스턴스는 this에 바인딩되며, 초기화하고 반환한다. 단 코드상에서 this가 아닌 다른 객체를 명시적으로 바인딩하면 해당 객체에 바인딩된다. +객체가 아닌 원시값을 바인딩하면 무시된다. new 연산자new 연산자 뒤에는 constructor 함수가 와야하며, 평가하면 해당 함수를 생성자 함수로 동작하게 한다. new없이 생성자 함수를 호출하면 일반 함수로 호출 된다. new.target(ES6)this와 비슷하게 모든 함수 내부에서 함수 자신을 가르키는 암묵적 지역 변수로 사용된다.new.target을 사용할 수 없는 상황이라면 스코프 세이프 생성자 패턴을 사용할 수 있다.","link":"/2020/02/28/%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%97%90-%EC%9D%98%ED%95%9C-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1/"},{"title":"스코프","text":"스코프란?어떤 식별자가 참조될 수 있는 유효한 범위를 말한다.스코프에 따라 어떤 변수나 함수를 참조할 지를 결정함으로 식별자가 호출 되었을 때 식별자를 검색할 때 사용하는 규칙이라고 볼 수 있다.같은 스코프에서 같은 식별자를 갖는 변수는 중복 선언을 할 수 없다.하지만, 스코프가 다르면 다른 변수로 취급하기 때문에 중복해서 사용 가능하며 서로 영향을 주지 않는다.단, 자바스크립트에서 var로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용된다. let, count(ES6)는 중복 선언을 허용하지 않는다. 스코프의 종류 전역코드 가장 바깥 영역.전역 스코프를 가지는 변수를 전역 변수라 하고 그 변수는 어디서든지 참조될 수 있다. 로컬블록문이나 함수 몸체 내부 영역.로컬 스코프를 가지는 변수를 로컬 변수라고 하며 그 변수는 해당 블록문이나 함수 몸체 내부에서만 참조 가능하다.자바스크립트는 블록문이 로컬 스코프로 갖지 않는다. 그래서 함수만 지역 스코프를 갖는다. 스코프 체인함수도 중첩이 되듯이 스코프도 중첩 가능하다. 따라서 모든 스코프는 계층적 구조로 연결되며 최상위에는 전역 스코프를 갖는다.이렇게 계층적 구조로 연결된 것을 스코프 체인이라고 한다.변수나 함수를 참조할 때, 스코프 체인을 따라 참조하는 변수의 스코프 부터 상위 스코프 방향으로 선언된 변수를 검색한다. 함수 레벨 스코프모든 언어는 지역 스코프를 코드 블록 단위로 생성한다. 하지만 자바스크립트의 var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 이런 특성을 함수 레벨 스코프라고 하며, 모든 코드 블록 단위로 스코프를 인정하는 것을 블록 레벨 스코프라고 한다.let, counst(ES6) 키워드로 생성된 변수는 블록 레벨 스코프를 지원한다. 렉시컬 스코프함수는 정의되고 호출 될 수 있다. 따라서 스코프를 가질 수 있는 경우의 수가 2가지 생기는데 호출된 위치에 따라 스코프를 갖는 것을 동적 스코프라 하고, 정의 될 때 스코프를 갖는 것을 정적 스코프 또는 렉티컬 스코프라 한다.자바스크립트는 렉티컬 스코프를 따른다. 코드의 인바이러먼스(환경)와 실행 컨텍스트(문맥)해당 코드의 위치나 주변의 코드들을 해당 코드의 환경이라고 하며, 그런 코드들의 환경을 모은 것을 실행 컨텍스트라고 한다.모든 코드는 실행 컨텍스트에서 실행된다.","link":"/2020/02/26/%EC%8A%A4%EC%BD%94%ED%94%84/"},{"title":"스프레드 문법","text":"스프레드 문법(ES6)하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다. 이터러블 객체에 한하여 사용가능하다.스프레드 문법의 결과물은 단독으로 사용할 수 없고, 아래와 같이 쉼표로 구분한 값의 목록을 사용하는 문맥에서만 사용할 수 있다. 스프레드 문법 사용처 함수 호출문의 인수 목록에서 사용하는 경우Rest 파라미터와 혼동 주의! 스프레드 문법은 인수에 사용하는 것이고 Rest 파라미터는 매개 변수에 사용하는 것이다. 배열 리터럴 내부에서 사용하는 경우push/concat/slice 메소드 대안으로 사용하면 좋음.splice를 이용한 배열 삽입 방법의 대안으로 사용하면 좋음유사배열 객체를 배열로 변환하기에 용이 객체 리터럴 내부에서 사용하는 경우(제안)Object.assign 메소드 대안으로 사용하면 좋음","link":"/2020/03/23/%EC%8A%A4%ED%94%84%EB%A0%88%EB%93%9C-%EB%AC%B8%EB%B2%95/"},{"title":"연산자","text":"연산자란?하나 이상의 표현식에서 산술, 할당, 비교, 논리, 타입, 지수 연산을 하게 하는 토근이다.피연산자를 연산하여 새로운 값을 만든다. = 표현식 이다. 부수효과란?대부분의 연산자는 피연산자에게 영향을 주지 않지만 단항 산술 연산자, 할당 연산자, delete 연산자의 경우 좌항 피연산자에게 반환되는 값을 재할당한다. 이것을 부수효과라고 한다. 산술연산자란?피연산자를 대상으로 수학적 계산을 수행해 새로운 값을 만드는 토큰이다. 이항 산술 연산자 (+,-,*,/,%)2개의 피연산자를 사칙연산을 하여 새로운 숫자 타입의 값을 만든다. 단항 산술 연산자 (++,–,+,-)1개의 피연산자를 증가/감소 한 후에 다시 할당을 하거나 음수를 양수로 양수를 음수로 변환하여 할당한다.숫자 타입이 아닌 피연산자에 + 단항 연산자를 사용시 숫자 타입으로 바꾸어준다. 문자열 연결 연산자 (+)피연산자 중에 하나라도 문자열이 포함되어 있을 경우 아닌 피연산자를 암묵적인 타입 변환을 통해 문자열로 바꾸어 하나의 문자열 값을 만든다. 할당 연산자 (=,+=,-=,*=,/=,%=)우항에 있는 피연산자의 평가 결과를 좌항에 변수에 할당 한다. 할당문은 우항의 평가 결과를 값으로 갖는 표현식이다. 비교 연산자란?피연산자를 비교하여 불리언 값을 반환하는 토큰이다. 동등/일치 비교 연산자 (==,===,!=,!==)피연산자가 같은 값을 갖는지 비교한다.동등 비교 연산자(==,!=)의 경우에는 암묵적인 타입 변환을 통해 타입을 일치시킨 후에 비교한다. NaN 값은 동등/일치 비교 연산을 할 경우 무조건 false 값을 출력한다. 비교하려면 isNaN()를 사용해야한다. 대소 관계 비교 연산자 (&gt;,&lt;,&gt;=,&lt;=)피연산자의 크기를 비교한다. 삼항 조건 연산자란?조건식의 평가 결과에 따라 반환할 값을 선택하는 삼항 조건 연산자 표현식에서 사용하는 토큰이다. (? :) 조건식은 불리언 타입으로 평가되어야 하기 때문에 조건식 평가 결과가 불리언 값이 아닐 경우 암묵적으로 불리언 타입으로 변환된다. 논리 연산자란?피연산자의 논리를 연산하는 토큰이다.논리합(||/or 연산), 논리곱(&amp;&amp;/and 연산), 부정(!/not 연산) 이 있다.피연산자를 암묵적으로 불리언 값으로 변환을 하여 연산한다.?? 불리언 값으로 평가 될 수 있다 ?? 쉼표 연산자란?, 왼쪽 피연산자 부터 평가하며 맨 오른쪽에 있는 피연산자의 값을 반환하는 토큰이다. 그룹 연산자란?() 표현식의 우선 순위를 높여준다. typeof 연산자란?피연산자의 데이터 타입을 문자열로 변환하는 토큰이다. null타입만 변환하지 못한다. null 타입은 object 객체로 반환한다. 선언하지 않은 식별자를 피연산자로 사용할 경우 undefined를 반환한다. 지수 연산자란?* 지수로 거듭 제곱한 숫자 값을 반환한다. *음수의 경우 괄호로 묶어주어야 한다. 모든 이항 연산자 보다 우선 순위로 연산한다.","link":"/2020/02/21/%EC%97%B0%EC%82%B0%EC%9E%90/"},{"title":"전역 변수의 문제점","text":"변수의 생명 주기변수가 생성되고 쓰레기 값이 될 때까지의 코드 상의 영역을 변수의 생명주기라고 한다. 전역 변수와 지역 변수 전역 변수란?전역 스코프, 즉 최상위 스코프에 선언된 변수를 의미한다. 자바스크립트에서 var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티로 저장된다. 지역 변수란?함수나 블록 문 단위로 지역 스코프에 선언된 변수를 의미한다. 단, 자바스크립트의 var 변수는 함수 레벨 스코프만을 인정하기 때문에 함수 안에 있는 변수를 의미하고 지역 스코프를 갖는다.지역 변수는 함수와 생명 주기를 같이 한다.호이스팅도 스코프를 단위로 동작한다. 전역 변수의 문제점전역변수는 전역 스코프를 갖기 때문에 다양한 문제가 발생한다. 암묵적 결합전역 변수는 모든 코드가 참조하고 변경할 수 있다. 이것을 암묵적 결합을 허용한다고 한다. 암묵적 결합을 허용하면 코드 여기 저기서 참조하고 변경 가능할 경우 변경될 가능성이 있다는 것이다. 긴 생명 주기전역 변수는 해당 프로그램이 끝날 때까지 참조할 수 있다. 이것은 프로그램이 끝날 때까지 메모리 공간을 차지하고 있다는 것이다. 또한 여기 저기서 참조 당해 변경 당할 가능성도 높다는 것이다. 스코프 체인 종점에 존재변수를 검색할 때 스코프 체인을 따라 검색을 하게 되는데 전역 변수는 스코프 체인 종점이기 때문에 검색 속도가 가장 느리다. (자바스크립트에서) 네임 스페이스 오염자바스크립트의 경우 여러 자바스크립트 파일을 참조하면 하나의 전역 스코프를 공유하게 된다. 그러면 다른 파일에서 선언한 변수와 식별자가 같으면 버그가 생길 수 있다. 전역 변수 사용 억제 방법전역 변수는 위와 같은 문제점들이 있기 때문에 사용할 이유가 없다면 지역변수를 사용해 변수의 스코프를 좁혀주는 것이 좋다. 즉시 실행 함수함수는 지역 스코프를 생성한다. 따라서 모든 코드를 함수로 묶어 즉시 실행하면 즉시 실행 함수의 지역 변수가 된다. 네임 스페이스 객체변수를 한 객체에 프로퍼티로 추가하고 그 객체의 키에 접근해서 변수 값을 사용하는 방법이다. 하지만 변수를 담을 객체가 전역 변수에 할당이 됨으로 효과적이지 않다. 모듈 패턴 사용관련있는 변수와 함수를 모아 즉시 실행 함수로 감싸 모듈을 만드는 방법이다. 모듈화를 하면 전역 변수 억제뿐 아니라 캡슐화까지 구현가능하다.캡슐화를 하면 필요한 정보만 보여줄 수 있는 정보 은닉을 시킬 수 있다. 모듈화한 함수를 변수로 할당하면 모듈화한 함수 안에서 반환할 값을 지정함으로서 공개할 데이터를 제한할 수 있다. 타입을 모듈로 지정(ES6)자바스크립트 파일을 실행할 html의 script 태그 type 어트리뷰트에 module 값을 부여하는 방법이 있다.모듈 파일 확장자는 mjs를 권장한다.","link":"/2020/02/27/%EC%A0%84%EC%97%AD-%EB%B3%80%EC%88%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/"},{"title":"실행 컨텍스트","text":"소스 코드의 타입소스 코드는 4가지로 분류할 수 있다. 이 소스 코드의 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르다. 전역 코드전역에 존해하는 소스 코드. 최상위 스코프인 전역 스코프를 생성 전역에 var 키워드로 선언된 변수와 함수를 전역 객체 프로퍼티와 메소드에 바인딩 함수 코드함수 내부에 있는 소스 코드. 지역 스코프를 생성 지역 변수와 매개 변수 관리 지역 스코프를 스코프 체인에 연결 eval 코드빌트인 전역 함수 eval 함수에 인수로 전달되어 실행되는 소스 코드. 엄격 모드에서 자신 만의 독자적인 스코프 생성 모듈 코드모듈 내부에 존재하는 소스 코드. 별도의 독립적인 스코프 생성 소스 코드의 평가와 실행소스 코드는 평가되고 실행하는 2단계로 자바스크립트 엔진에서 동작한다. 소스 코드의 평가실행 컨텍스트를 생성하고 변수, 함수 등의 선언문을 먼저 실행한다. 그리고 선언문으로 등록된 식별자를 실행 컨텍스트가 관리하는 스코프(렉시컬 환경 레코드)에 등록한다. 소스 코드의 실행선언문을 제외한 소스 코드가 순차적으로 실행된다. 실행 컨텍스트식별자(변수, 함수, 클래스 등의 이름)을 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘이다.식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리하고, 실행 순서는 실행 컨텍스트 스택으로 관리한다. 실행 컨텍스트 스택실행 컨텍스트를 실행하는 순서를 메모리에 담아 순서대로 실행하는 자료 구조이며, 스택 자료 구조로 관리된다.최상위 실행 컨텍스트가 종료되면 어플리케이션이 종료된 것이며, 따라서 최상위 컨텍스트는 언제나 현재 실행 중인 코드의 실행 컨텍스트이다.이를실행 중인 실행 컨텍스트라고 한다. 동기식 처리 모델과 비동기식 처리 모델자바스크립트 엔진은 하나의 실행 컨텍스트 스택을 갖는 싱글 스레드로 동작한다. 원래 싱글 스레드로 동작하면 동시에 2가지 이상의 일을 할 수 없기 때문에 동기식 처리 모델이지만 자바스크립트는 비동기식 처리 모델을 지원한다.Timer 함수, Ajax 요청은 비동기식 처리 모델로 동작한다. 렉시컬 환경실행 컨텍스트를 구성하는 컴포넌트로 객체 형태의 스코프를 생성하여 식별자를 키로 등록하고 식별자에 바인딩 된 값을 관리하며 상위 스코프에 대한 참조를 가진다. 각 기능을 가진 컴포넌트로 구성되어 있다. 환경 레코드 : 스코프에 포함된 식별자를 등록하고 바인딩된 값을 관리. 전역 환경 레코드 객체 환경 레코드 :전역 객체에 등록해야할 변수들을 등록을 관리. 선언적 환경 레코드 :전역 스코프에 등록해야할 변수들을 등록을 관리. 함수 환경 레코드 객체 환경 레코드 :전역 객체에 등록해야할 변수들을 등록을 관리.전역 환경 레코드와 같다 선언적 환경 레코드 :함수 지역 스코프에 등록해야할 변수들을 등록을 관리.단, 전역 환경 레코드와 차이는 추가적으로 argument 객체나 매개 변수, 등을 암묵적으로 등록한다. 외부 렉시컬 환경에 대한 참조 : 상위 스코프, 즉 상위 스코프를 생성하는 외부 렉시컬 환경에 대한 참조. 단방향 링크드 리스트인 스코프 체인을 구현한 것. 실행 컨텍스트의 생성과 실행 과정 전역 객체 생성 : 전역 프로퍼티와 전역 함수, 표준 빌트인 객체, 동작 환경에 따른 호스트 객체를 포함해서 생성한다. 전역 코드 평가 전역 실행 컨텍스트 생성 전역 렉팉컬 환경 생성 전역 환경 레코드 생성 : 전역 변수, 함수, 표준 빌트인 함수, 전역 빌트인 프로퍼티 및 메소드를 등록. 객체 환경 레코드 생성 :var 키워드로 선언한 전역 변수 및 함수를 전역 객체의 프로퍼티 및 메소드로 등록. 선언적 환경 레코드 생성 :let, const 키워드로 선언한 전역 변수 및 함수를 등록. this 바인딩 외부 렉시컬 환경에 대한 참조 할당 전역 코드 실행 식별자 결정(식별자 검색)을 실행 컨텍스트에서 검색. 함수 호출 시, 함수 코드 평가 &gt; 함수 코드 실행 &gt; 함수 코드 종료 순으로 동작. 함수 코드 중에 함수가 호출되면 앞의 순서를 반복.함수 코드 평가는 위에 전역 코드 평가에서 전역을 함수로 바꾸면 똑같이 동작한다. 전역 코드 실행 종료 실행 컨텍스트와 블록 레벨 스코프코드 실행중 문을 실행할 때, 안에 let이나 const로 변수를 선언하면 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 만들고 기존의 전역 렉시컬 환경을 교체한다. 그리고 기존의 전역 렉시컬 환경은 외부 렉시컬 환경에 대한 참조에 바인딩된다.","link":"/2020/03/12/%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"},{"title":"원시 값과 객체의 비교","text":"원시 값원시 타입(숫자, 문자열, Boolean, null, undefined, symbol 타입)인 값이다. 변경이 불가능한 값이다.변하지 않는 값(불변성)이기 때문에 데이터의 신뢰성을 보장한다. 변수와 상수원시 값은 변경이 불가능하다. 하지만 변수 값은 변경이 가능하다. 원시 값은 메모리에 들어가 있는 데이터이고 변수 값은 해당 변수가 갖고 있는 메모리 주소에 들어있는 값을 참조하는 것이기 때문에 변수의 경우는 재할당을 통해 변수 값을 변경 가능하다.그 중 상수라는 개념이 있는데 상수란 재할당을 금지한 변수이다. 상수도 변수의 일종이지만 시스템적으로 재할당을 금지했을 뿐이다. 때문에 한번만 할당이 가능하다. 문자열타입 값문자열도 원시 타입의 값이다. 따라서, 한번 선언되 문자열 값은 바꿀 수 없다.아래 예시를 보자. ex1) 문자열 값 재할당 var str = 'hellow'; str = 'Hellow'; 위의 예시는 ‘hellow’란 문자열을 만들고 이 문자열 중 첫번째 문자를 대문자로 바꾸고 싶어 ‘Hellow’란 문자열로 재할당하는 코드이다.하지만 실행하면 h를 H롤 바꾼 것이 아니라 ‘hellow’란 값은 그대로 두고 ‘Hellow’란 값을 다시 만들어서 재할당 한 것이다. 추가로, 문자열 타입의 값은 유사 배열 객체이다. 정확히는 배열 객체처럼 사용할 수 있다.특정 문자를 접근하는 것은 가능하나 변경은 할 수 없다. 다음 예제를 보자 ex2) 특정 문자 접근 및 수정 ... str[0]; // -> H str[0] ='h'; console.log(str); // 'Hellow' 주의해야 할 점은 특정 문자를 변경하려고 쓴 문(str[0] = ‘h’;)은 무시되었지만 에러를 출력하지 않는다. 객체 타입의 값객체 타입의 값은 프로퍼티 갯수가 정해저 있지 않으며 추가되고 삭제 할 수 있다. 즉, 변경가능한 값이다.따라서 원시 값 처럼 사전에 메모리 공간을 확보할 수 없다. 객체 타입의 값 관리객체 타입 값은 프로퍼티들로 이루어져있고 프로퍼티는 키와 프로퍼티 값으로 이루어져있다. 프로퍼티 값은 해당 객체 안에 포함되어있지 않고 다른 메모리에 저장되어 있는데 그 메모리 주소를 그 프로퍼티의 키가 갖고 있고 해당 프로퍼티를 호출하면 키가 갖고 있는 주소로 가서 그 메모리에 저장된 값을 가져온다. 변수를 통한 원시 값 접근과 객체 타입의 값 접근 비교변수에 원시 값을 할당하면 원시 값 자체를 변수 값으로 갖는다. 하지만 객체 타입의 값을 할당하면 해당 객체 값이 있는 주소를 값으로 가져서 주소를 값으로 만든다. 이렇게 주소를 값으로 갖는 것을 참조 값이라고 한다.즉 객체 타입의 값을 할당한 변수는 값으로 참조값를 갖는 것이다. 값의 전달어떤 변수에 다른 변수 값을 할당하고 싶은 경우가 있을 수 있다. 그럼 할당 연산자를 통해 값을 전달할 수 있다.전달을 할 때 할당을 하는 변수 값을 복사해서 다른 메모리에 재할당하고 그 메모리 주소를 연결하던가 아님 애초에 할당하는 변수의 연결된 주소를 공유할 수 도 있다.여기서 객체 타입의 값은 문제가 생긴다. 할당을 하는 변수의 연결된 주소를 공유를 하던 복사를 해서 재할당을 하던 그 참조값은 할당하는 변수나 할당 받는 변수나 같은 객체 주소를 참조하게 된다. 따라서 이렇게 참조 값을 전달한 후 그 안에 있는 객체 프로퍼티 또는 프로퍼티 값을 수정하면 그 객체 주소를 참조하는 모든 변수가 영향을 받는다는 말이 된다.변수로 값을 전달하는 것을 ‘공유에 의한 전달’이라고 하며, 원시 값을 전달하는 것을 ‘값에 의한 전달’, 참조 값을 전달하는 것을 ‘참조에 의한 전달’이라고도 한다. ex3) 객체 타입의 값 전달 var obj = {name : object}; var copy = obj; console.log(copy === obj); // true // 각 변수의 변경점을 만든다. copy.name = copyName; obj.add = 'ok'; console.log(copy, obj); // {name : copyName, add : 'ok'}, {name : copyName, add : 'ok'}","link":"/2020/02/26/%EC%9B%90%EC%8B%9C-%EA%B0%92%EA%B3%BC-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B9%84%EA%B5%90/"},{"title":"엄격 모드","text":"엄격 모드란?ES5부터 적용된 자바스크립트의 문법을 보다 엄격하게 적용하여 무시되던 오류 발생 가능성이나 엔진 최적화에 문제가 될만한 코드에 에러를 발생시키는 모드이다. 엄격 모드 적용하기전역 선두 또는 함수 몸체의 선두에 ‘use strict’을 추가한다. 주의점 전역에 사용하는 것스크립트 단위로 적용되나 적용할 스크립트와 적용 안할 스크립트를 혼용할 경우, 오류를 발생시킬 가능성이 있음으로 전역 선두에 사용하는 것은 최대한 자제하는 것이 좋다. 함수 단위에 사용하는 것함수에 일일이 적용하는 것도 비효율적이며, 엄격 모드가 적용된 함수에서 적용 안된 함수를 참조할 때 오류를 발생할 가능성이 높기 때문에 함수 단위로 적용하는 것은 좋지 않다. 따라서 스크립트 단위을 즉시 실행 함수로 묶어 적용시키는 것이 바람직하다. 엄격 모드가 발생시키는 에러 암묵적 전역선언하지 않는 변수를 참조하면 ReferenceError를 발생시킨다. 변수, 함수, 매개 변수의 삭제delete 연산자로 변수, 함수, 매개 변수를 삭제하면 SytaxError를 발생시킨다. 매개 변수 이름 중복중복된 함수 매개변수 이름을 사용시 SytaxError를 발생시킨다. with 문의 사용with 문을 사용하면 SytaxError를 발생시킨다. 엄격 모드 적용 시의 변화 일반 함수의 this생성자 함수가 아닌 일반 함수로 호출하면 this에 undefined가 바인딩된다. argument 객체매개 변수에 전달된 인수를 재할당하여 변경하여도 argument 객체에 반영되지 않는다.","link":"/2020/03/10/%EC%97%84%EA%B2%A9%EB%AA%A8%EB%93%9C/"},{"title":"제어문","text":"제어문이란?제어문을 사용하면 코드의 실행의 흐름을 제어할 수 있다. 블록문0개 이상의 문을 중괄호로 묶은 것.함수 정의할 때 사용하는 것이 일반적블록문 뒤에는 ;을 붙이지 않는다. 조건문 if…else 문주어진 조건식의 평가 결과에 따라 블럭문을 실행할지 결정.참인 경우 다음 블록을 실행, 거짓인 경우 else 문 다음의 블록문을 실행한다. 조건문이 불리언 값이 아닌 값으로 평가 될 때는 암묵적 타입 변환으로 불리언 값으로 변환되어 실행한다.*코드 내에 블록문 뒤에 switch 문주어진 조건식의 평가 경과에 따라 case문의 실행을 결정한다.조건식이 반드시 불리언 값이 필요가 없다. 다양한 상황에 따라 실행할 코드 블록을 결정한다.case 문은 break;로 끝내주지 않으면 무조건 defult 문를 실행한다.(풀스루)반드시 해당 case에서 실행을 끝내고 싶을 경우 break;로 끝내주어야 한다. 반복문주어진 조건식의 결과가 참인 경우 계속 실행하고 거짓일 경우 까지 반복한다. for 문조건식의 변수 선언 후 조건식을 설정하고 증감식을 작성하는 것이 문법이다.ex) for (var i=0;i&lt;5;i++) { } 어떤 식도 선언하지 않으면 무한 루프를 한다.for 문을 중첩해 사용가능하다.-while 문증감식이 없이 조건식만 평가하여 결과가 참이면 코드 블록을 반복한다.do while문은 일단 조건식을 평가하지 않고 무조건 코드 블록을 한번 실행한다. 그리고 조건식을 평가한다. break 문코드 불록을 탈출한다. 레이블 문이다. 레이블 문이란?식별자가 붙어 식별자로 실행하는 분을 말한다. continue 문break 문이 코드 불록을 아예 탈출한다면 continue 문은 증감식으로 이동한다.","link":"/2020/02/24/%EC%A0%9C%EC%96%B4%EB%AC%B8/"},{"title":"타입 변환과 단축 평가","text":"타입 변환 이란?컴퓨터에서 입력되는 모든 값은 타입이 있다. 이 타입은 값이 처음 만들어질 때 확정이 되는데 친절한 javascript 는 참조하는 과정에서 의도적이든 암묵적으로 javascript 엔진에 의해 타입 변화가 일어는 경우가 생긴다. 암묵적 타입 변환표현식을 평가할 때 문맥을 고려하여 암묵적으로 값의 타입이 변환되는 것을 암묵적 타입 변환 또는 타입 강제 변환이라고 한다. 문자열 타입으로 변환‘+’ 연산자의 기능 중 문자열 연결 연산자를 사용해서 문자열 값을 만드는 것이다.피연산자 중에 하나라도 문자열 타입의 값이 있다면 나머지 값도 문자열 타입으로 암묵적 타입 변환한다. ex) 1 + ' ' // -> '1' symbol 타입은 어떠한 경우라도 문자열로 변환될 수 없다. 변환하려고 하면 TypeError를 출력한다.객체 타입은 문자열로 변환시 이상하게 나온다. 빈 배열 객체는 빈 문자열로 평가되며 배열 객체의 식별자를 참조하면 함수로 나온다. 숫자 타입으로 변환이항 산술 연산자 ‘+’를 제외하고 나머지 산술연산자는 숫자 타입의 값을 만드는 것이다.피연산자 중 숫자 타입 아닌 모든 값을 암묵적으로 숫자 타입으로 변환한다. ex1) +'1' // -> 1 ex2) +'ten' // -> NaN ex3) +true[/false] // -> 1[/0] ex4) +null // -> 0 ex5) +undefined // -> NaN ex6) +Symbol() // -> TypeError : Cannot convert a Symbol value to a number ex7) +{} // -> NaN ex8) +[] // -> 0 ex9) +[value1, value2] // -> NaN ex10) +(function( ){ }) // -> NaN Boolean 타입으로 변환논리 연산자는 Boolean 값을 비교해야 하며, 조건문의 평가 결과는 Boolean 값으로 평가 되어야 한다.조건문 안에 표현식이나 논리 연산자의 피연산자는 암묵적으로 Boolean 타입의 값으로 변환된다. false로 평가돠는 값 ) ‘false’ undefined null +0,-0 NaN ‘’(빈문자열) 위의 false 값으로 변환되는 경우를 제외하면 모두 true로 변환한다.논리 연산자 중 &amp;&amp; 와 || 의 경우는 평가를 할 때는 암묵적 타입 변환이 일어나지만 평가되는 값은 해당 표현식에 값을 결정하는 피연산자 표현식의 값으로 평가한다. // 조건문 ex1) if(NaN){ } // NaN -> false ex2) if('string'){ } // 'string' -> true // 논리 연산자 ex3) !!null // null -> false ex4) !!2 // 2 -> true 명시적 타입 변환의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라고 한다.표준 빌트인 생성자 함수를 new연산자 없이 호출하는 방법과 빌트인 메소드를 사용하는 방법, 암묵적인 타입 변환을 이용해 재할당하는 방법이 있다. 문자열 타입으로 변환 String 생성자 함수 Object.prototype.toString 메소드 문자열 연결 연산자 ex1) String('true') // -> 'true' ex2) (Infinity).toString() // -> 'Infinity' ex3) null + '' // -> 'null' 숫자 타입으로 변환 Number 생성자 함수 parseInt, parseFloat 함수 문자열만 가능 단항 산술 연산자 + , - 이항 산술 연산자 - , * , / ex1) Number('true') // -> 1 ex2) parseInt('10') // -> 10 ex3) +'' // -> 0 ex4) undefined * 1 // -> NaN Boolean 타입으로 변환 Bloolean 생성자 함수 부정 논리 연산자 두번 !! ex1) Boolean('10') // -> true ex2) !!NaN // -> false 단축 평가논리 연산자 표현식의 경우 평가되면서 값에 결정을 하는 피연산자가 생기는 것을 단축 평가라고 한다.이 때 좌항 피연산 표현식의 암묵적 타입 변환 까지 일어난 후에 논리 연산자 표현식의 값으로 평가되는 표현식이라면 우항의 표현식을 평가하지 않는다. &amp;&amp;(논리 곱 / and 연산)피연산자 중 하나라도 false 인 경우 해당 논리 연산자 표현식의 평가는 무조건 false 이다. 따라서 좌항 피연산 표현식의 암묵적 타입 변환 까지 일어난 후에 평가되는 값이 false 라면 뒤에 표현식을 평가하지 않는다. ex) -1 > 0 && 1 + 3 // -1 > 0 && 1 + 3 -> false ||(논리 합 / or 연산)피연산자 중 하나라도 true 인 경우 해당 논리 연산자 표현식의 평가는 무조건 true 이다. 따라서 좌항 피연산 표현식의 암묵적 타입 변환 까지 일어난 후에 평가되는 값이 false 라면 뒤에 표현식을 평가하지 않는다. ex) '참' && nell // '참' && null -> '참' 값은 암묵적으로 타입 변환이 된 값이 아닌 원래 표현문이 평가된 값으로 평가된다. if 문은 단축 평가로 대체가 가능하다. var shortCut; var bln = [표현식]; if (bln) shortCut = '참' else shortCut = '거짓'; // bln에 할당되는 표현식이 true로 표현될 때 실행 shortCut bln && '참'; // bln 에 할당되는 표현식이 false로 표현될 때 실행 shortCut bln || '거짓';","link":"/2020/02/24/%ED%83%80%EC%9E%85-%EB%B3%80%ED%99%98%EA%B3%BC-%EB%8B%A8%EC%B6%95-%ED%8F%89%EA%B0%80/"},{"title":"함수","text":"함수란?프로그래밍에서 함수란 하나의 실행단위이다. 프로그램이 여러 문(명령)들의 집합이면 그 중에 몇몇 문들을 재사용하기 위해 작은 프로그램으로 실행 단위를 묶은 것이다. 함수는 수학에서 정의 하는 함수처럼 입력과 출력이라는 개념이 있다. 특정 문들을 실행하기 위해 입력 받는 변수를 매개변수라고 하고 입력 하는 값을 인수, 출력되는 값을 반환값이라 한다.함수 정의를 통해 생성하며, 인수를 매개변수로 전달하여 함수를 실행하고 변환값을 받는 것을 함수 호출이라고 한다. 1234567// 함수 정의function consoleFunc(p) { console.log(p);}// 함수 호출var result = consoleFunc('함수 호출!'); // '함수 호출!' 함수 사용 이유 코드의 재사용 용이 코드 유지보수 용이 코드 신뢰성 상승 효과 코드의 가독성 향상 함수 리터럴이란?함수는 객체 타입의 값이다. 따라서 함수도 함수 리터럴로 생성가능하다.함수 리터럴은 function 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성된다. function 키워드 :함수라는 것을 엔진에게 명시 함수 이름 :함수 자신을 가르키는 식별자이다. 식별자 규칙을 따라야 한다. 함수 안에서만 참조 가능하며, 생략 가능하다. 주의할 점은 함수 안에서 자신을 불러오기 위해 사용되는 이름이지 함수를 호출하기 위해서 쓰는 것은 아니다. 함수를 할당한 식별자와 혼동하지 말것. 매개변수 목록 :‘()’ 안에 매개 변수를 쉼표(,)로 구분한다. 호출문에 인수들이 순서대로 할당된다. 매개 변수의 스코프(유효범위)는 함수 내부이다. *초기값으로 ‘undefined’이 할당되있다. 함수 몸체 :함수가 호출 될 때 실행될 문들의 코드 블록이다. 주의 해야할 점은 함수는 객체긴 하지만 일단 객체와 다르다. 함수 객체만의 고유 프로퍼티를 갖으며 그에 따라 호출할 수 있다. 함수 정의함수를 정의한다는 것은 함수 객체 값을 만든다는 것이다라고 볼 수 있다.함수를 정의하는 방법은 4가지가 있다. 함수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수(ES6)가 있다. 함수 선언문‘function’+’함수 이름’+’()’+’{}’ 의 기본 형식을 따른다. 함수 선언문은 함수 이름을 생략 할 수 없다. 표현식이 아닌 문이다. 실행되면 완료값을 출력한다.(undefined) 함수 호이스팅이 일어난다. 즉, 함수 객체 값을 런타임 이전에 생성한다.undefined를 할당하는 변수 선언문에서 되는 호이스팅과 다르게 함수 선언문에서 호이스팅될 때는 함수 객체 값을 할당한다. 자바스크립트 엔진에서 함수 선언을 하는 과정을 만든다. 암묵적으로 식별자를 만든다. 12345678function obj () { console.log('obj');}// 위에 선언식은 아래 문과 비슷하게 작동한다.var obj = function obj () { console.log('obj');} 함수 표현식처럼 썼지만 엄연히 생성 시점이 다르다. 표현식과 차이가 있다. 함수 표현식함수 선언식과 똑같이 ‘function’+’함수 이름’+’()’+’{}’ 의 기본 형식을 따른다. 함수 표현식은 함수 이름을 생략할 수 있다. 이름을 생략한 함수 표현식을 익명 함수라고 하고, 기입한 것을 기명 함수라고 한다. 일반적으로 익명 함수 표현식을 사용한다. 기명 함수 표현식은 함수 내에서 재귀할 경우에만 사용한다. 표현식인 문이다. function 객체 값을 반환하며 변수에 할당해줄 수 있다. 값의 성질의 값는 일급 객체이다. 함수 리터럴이 표현식으로 평가되는 순간 생성한다. Function 생성자 함수자바스크립트가 제공하는 빌트인 함수인 Function 생성자 함수에 인수로 매개 변수 목록과 함수 몸체에 들어갈 문들을 문자열로 전달하며 호출하면서 new 연산자로 연산하면 함수 객체 값을 생성한다. 당연히 함수를 식별할 변수를 지정해 주어야한다. 함수 표현식처럼 작동한다. 하지만 클로저를 생성하지 않는 등, 함수 선언식이나 표현식과 다르게 동작함으로 사용을 지양해야한다. Function 함수가 실행되면서 함수 객체를 만든다. 123456var obj = new Function('console.log('obj')');// 위에 할당문은 아래 문처럼 작동한다.var obj = function obj () { console.log('obj');} 화살표 함수function 키워드 대신에 =&gt;를 사용해 함수를 정의할 수 있다. ‘()’+’=&gt;’+’{}’의 형식을 가지며, {}안에 실행한 문이 한개면 생략 가능하다. 생성자 함수로 사용할 수 없다. 기존 함수와 this 바인딩이 다르다. prototype 프로퍼티가 없다. arguments 객체를 생성하지 않는다. 1const obj = () =&gt; {console.log('obj')}; 함수 호출함수를 가르키는 식별자와 인수를 넣을 함수 호출 연산자(‘()’)를 사용해서 함수를 호출한다.함수 호출 연산자에는 인수를 쉼표(,)로 구분하여 나열한다. 인수 인수는 값으로 평가될 수 있는 표현식이여야한다. 자바스크립트는 매개변수와 인수의 개수가 일치하는 지 확인하지 않는다. 매개변수의 수보다 많은 인수를 넣을 경우, 넘치는 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관되지만 함수 내에서 사용되지는 않는다. 매개 변수 매개 변수 초기값인수가 전달 되지 않아 부적절한 호출이 되지 않게 매개 변수를 초기화를 해주는 것을 권장한다.단축평가를 이용하는 방법과 매개 변수 기본값(ES6)를 사용해서 기본값을 할당하는 방법이 있다. 123456789101112// 단축평가를 이용한 매개 변수 초기화 function obj (a,b,c) { a = a || 0; b = b || ''; c = c || true; return c ? b : a; } // 매개 변수 기본값을 이용한 초기화 function obj(a = 0, b = '', c = true){ return c ? b : a; } 매개 변수 최대 갯수제한을 두고 있지 않지만 많은 매개 변수를 사용하면 함수 사용법을 어렵게 만들고 실수가 생길 가능성이 높고, 유지보수하기도 어려워져서 3개 이상 사용하지 않는 것을 권장하고 있다.적으면 적을 수록 좋으며, 3개 이상을 써야할 경우 객체를 인수로 받아 사용하는 것이 좋다.하지만 객체를 인수로 받을 경우 함수 내부에서 변경이 있을 때 함수 외부에도 영향을 주는 부수효과가 발생하니 주의를 요한다.부수효과를 해결하기 위해서는 여러방법이 있는데 그중 인수로 받는 객체를 불변 객체로 만들어주는 방법이 있다. 반환문일반적으로 완료값(undefined)을 출력하지만 return 키워드를 이용해서 반환문을 만들어 그 안에 반환값을 함수 외부로 반환할 수 있다.주의할 점은 return 키워드를 사용하면 반환문 실행 후 함수 실행을 중단하고 함수를 빠져나간다.또한 반환문에서 줄바꿈을 할 경우 세미콜론 자동 삽입 기능에 의해 줄바꿈 이후에 줄이 무시된다. 12345function obj () { return 'obj';}console.log(obj()); // 'obj' 함수의 형태 즉시 실행 함수함수를 정의함과 동시에 즉시 호출하는 것을 즉시 실행 함수라고 한다. 단 한번만 호출되며 다시 호출할 수 없다. 따라서 익명함수 표현식을 사용하는 것이 일반적이다.이것은 함수를 즉시 호출하기 위해서는 함수 표현식으로 평가되어야한다는 것을 의미한다. 재귀 함수함수 자신을 호출하는 문이 포함된 함수이다. 반드시 탈출 조건을 만들어야 한다. 안그러면 무한으로 호출하여 stack overflow 에러가 발생한다.재귀 함수를 만들기 위해서는 반드시 함수가 할당된 식별자가 있고 그 식별자를 함수 안으로 가져와서 문을 작성하면 된다. 중첩 함수함수 내부에 또 다른 함수 선언된 함수를 중첩 함수라고 한다.중첩 함수를 포함한 안에 또 다른 함수가 들어있는 함수를 외부 함수라고 하며, 안에 있는 함수를 내부 함수 또는 헬퍼 함수라고 한다. 콜백 함수와 고차 함수함수의 매개변수로 다른 함수를 갖는 함수를 고차함수라고 한다. 고차 함수에서 매개 변수를 통해 전달받는 함수를 콜백 함수라고 한다.중첩 함수와의 차이는 중첩함수는 함수 내에 선언을 하기 때문에 내부에 함수를 고치면 함수를 재선언을 해야하지만 콜백함수는 고차함수에 의해 매개변수로 들어가는 것이기 때문에 교체나 수정이 자유롭다는 장점이 있다.호출 시점은 고차함수가 호출 시점을 결정한다. 순수 함수와 비순수 함수순수 함수는 부수효과가 없는 함수를 순수 함수라 하고, 부수 효과가 있는 함수를 비순수 함수라고 한다.변수 사용을 최대한 억제하고 순수 함수와 보조함수로 조건문과 반복문을 제거하여 복합성을 해결하는 프로그래밍을 함수형 프로그래밍이라고 한다.","link":"/2020/02/26/%ED%95%A8%EC%88%98/"},{"title":"클로저","text":"렉시컬 스코프함수를 어디서 호출했는지에 따라서가 아니라 어디서 정의 했는지에 따라 상위 스코프를 결정하는 방식을 렉시컬 스코프라고 한다.= 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 참조값은 함수가 평가되는 시점, 즉 함수가 정의된 환경에 의해 결정한다. 내부 슬롯[[Environment]]렉시컬 스코프가 가능하기 위해서 함수는 호출되는 환경과 관계없이 정의된 시점의 상위 스코프를 기억해야하는데 기억하는 공간이 내부 슬롯[[Environment]]이다.즉, 내부 슬롯[[Environment]]은 함수 정의가 평가되는 시점에 실행중인 컨텍스트의 렉시컬 환경의 외부 렉시컬 환경에 대한 참조값을 저장한다. 클로저와 렉시컬 환경클로저란? 중첩함수가 외부함수의 변수를 참조하고 있을 때, 해당 중첩함수를 반환하여 외부함수가 소멸하더라도 중첩함수로 외부 함수의 변수에 접근할 수 있는 그런 중첩함수를 말한다.모든 함수는 내부슬롯 [[Enviroment]]에 자신의 상위 스코프를 기억하기 때문에 어떤 함수에서 반환한 함수가 반환을 했던 함수를 참조할 수 있다는 말이다. 자유변수 : 클로저에 의해 참조되는 상위 스코프의 변수를 말한다. 클로저의 활용 상태를 안전하게 유지(은닉) 및 변경 상태 유지클로저를 통해서만 자유변수를 조작할 수 있다. 함수 외부에서는 참조할 수 없다. 또한, 클로저를 통해 변경한 자유변수는 변경 상태를 유지한다. 독립된 렉시컬 환경클로저 함수를 호출해 함수를 반환할 때마다 독립된 레시컬 환경을 갖는다.새로 호출한 클로저로 반환된 함수는 이전에 호출한 클로저로 반환한 함수와는 독립적으로 작동한다.","link":"/2020/03/17/%ED%81%B4%EB%A1%9C%EC%A0%80/"},{"title":"프로토타입","text":"객체 지향 프로그래밍객체 지향 프로그래밍이란 명령어와 함수 목록으로 보는 전통적 명령형 프로그래밍에서 벗어나 여러개의 독립적인 단위, 객체들의 집합으로 표현하려는 프로그래밍 페러다임을 말한다. 각 객체는 해당 객체의 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조인 것이다.객체의 속성에는 상태를 나타내는 프로퍼티와 상태 데이터를 조작할 수 있는 메소드를 하나의 논리적 단위로 묶는다. 상속상속이란 객체 지향 프로그래밍의 핵심 개념으로 어떤 객체의 프로퍼티나 메소드를 다른 객체가 상속받아 사용하는 것을 말한다.상속은 불필요한 중복을 제거하며, 코드를 재사용 가능하게 한다. 자바스크립트에선 프로토타입을 기반으로 상속을 구현한다. 프로토타입프로토타입이란 어떤 객체의 상위(부모) 객체의 역활을 하는 객체를 나타내며 프로토타입을 상속받은 모든 객체는 프로토타입의 프로퍼티를 자유롭게 사용 가능하다. poroto접근자 프로퍼티모든 객체는 poroto접근자 프로퍼티를 통해 해당 객체의 프로토타입에 접근가능하다.poroto접근자 프로퍼티는 setter 함수와 getter 함수를 통해 새로운 프로토타입을 취득 및 할당이 가능하다.주의할 점은 poroto접근자 프로퍼티는 해당 객체에 있는 것이 아니라 그 객체의 프로토타입 객체에 있는것이다. 상속 받아 사용하는 것임을 명심할 것또한 프로퍼티 검색 방향을 한쪽으로만 흘러가는 단방향 링크드 리스트로 구현해야한다. prototype 프로퍼티함수 객체에는 prototype 프로퍼티를 갖는다. prototype 프로퍼티는 생성자 함수가 생성할 객체(인스턴스)의 프로퍼타입을 지정한다.해당 함수객체의 prototype 프로퍼티 참조값은 생성자 함수로 생성되는 객체(인스턴스)의 proto접근자 프로퍼티의 참조값, 즉 생성된 객체의 프로토타입과 같다.리터럴 표기법에 의해 생성된 객체도 가상적인 생성자 함수를 갖고 해당 객체가 어떤 객체인지에 따라 다른 프로토타입을 갖는다. 프로토타입의 constructor 프로퍼티constructor 프로퍼티는 prototype 프로퍼티로 해당 프로토타입을 참조하고 있는 모든 생성자 함수들을 객체로 값을 갖는 프로퍼티이다.생성자 함수가 생성될 때, 연결된다. 프로토타입 생성 시점 (사용자 정의) 생성자 함수생성자 함수로서 호출할 수 있는 함수는 해당 생성자 함수가 평가되어 함수 객체를 생성하는 시점에서 프로토타입도 더불어 생성된다.생성자 함수로 호출할 수 없는 함수, 즉 non-constructot 함수는 프로토타입이 생기지 않는다.non-constructor 함수는 화살표 함수나 ES6의 메소드 축약표현으로 정의된 함수들이 있다.*생성자 함수를 함수 선언문으로 정의하면 함수 호이스팅이 일어남으로 런타임 이전에 함수 객체가 생성되며 프로토타입도 생성된다. 빌트인 생성자 함수빌트인 생성자 함수도 생성되는 시점에서 프로토타입이 생성된다. 그리고 모든 빌트인 함수 전역 객체에 포함되어 있고 런타임 이전에 자동적으로 생성됨으로 런타임 이전에 프로토타입도 같이 생성된다.빌트인 함수는 전역 객체의 프로퍼티에 포함되어 있다. 전역 객체 안에는 표준 빌트인 객체, 환경에 따른 호스트 객체, var 키워드로 선언한 전역 변수, 전역 함수를 프로퍼티로 갖는다. 그리고 이 전역 객체는 가장 먼저 생성된다. 객체 생성 방식에 따른 프로토타입 결정모든 객체는 자바스크립트 엔진에 의해 추상연산 ObjectCreate 에 의해 생성된다. 객체 리터럴/Object 생성자 함수에 의해 생성된 객체의 프로토타입객체 리터럴도 Object 생성자 함수에 의해 생성한 것처럼 Object.prototype 객체를 프로토타입으로 갖는다.단지, 객체 생성 방식에 차이가 있다. 객체 리터럴은 객체 내부에 프로퍼티를 추가하지만 생성자 함수로 생성된 객체는 빈 객체를 만들고 프로퍼티를 추가 해야하는 차이가 있다. 생성자 함수에 의해 생성된 객체의 프로토타입빌트인 생성자 함수가 아닌 (사용자 정의된) 생성자 함수도 Object.prototype 객체를 프로토타입으로 갖는다.단, 객체 리터럴과 Object 생성자 함수와 다른 점은 만들어진 prototype이 constructor프로퍼티만을 갖는다는 점이다. 프로토타입 체인자바스크립트는 객체의 프로퍼티를 접근할 때, 해당 프로퍼티가 없으면 proto접근자 프로퍼티의 참조를 따라 prototype 객체의 프로퍼티를 순차적으로 검색하고 있을 경우, 상속을 받는데 이를 프로토타입 체인이라 한다.모든 프로토타입 체인의 최상위 객체는 Object.prototype 객체이다.Object.prototype 에서도 프로퍼티를 검색할 수 없는 경우 에러가 뜨지 않고 undefined 를 반환한다. 캡슐화캡슐화란 정보의 일부를 외부에 감추어 은닉하는 것을 말한다.즉시실행함수등을 이용해서 적절치 못한 접근을 예방하고 정보를 보호하며, 객체간의 상호 의존성을 낮추는 효과가 있다. 오버라이딩과 프로퍼티 쉐도잉 오버라이딩프로토타입등의 상위 클래스가 가지고 있는 메소드를 상속을 받는 객체에서 재정의하여 사용하는 방식이다. 오버로딩함수 이름만 같고 매개 변수의 타입이나 갯수로 구별하여 다른 메소드를 호출하는 방식이다. 프로퍼티 쉐도잉오버라이딩에 가려져 보이지 않는 상위 클래스의 메소드를 말한다. 프로토타입 교체프로토타입 객체는 교체가 가능하다. 재할당하여 참조값을 바꾸면 된다.단, 중요한 것은 프로토타입 객체를 생성하여 교체할 시 교체된 객체에 constructor 프로퍼티가 없거나 생성자 함수와 연결되있지 않는 경우, 생성자 함수와 프로토타입 간에 연결이 끊긴다. 생성자 함수에 의한 프로토타입 교체‘생성자 함수’.prototype 에 교체할 프로토타입 객체를 할당해주면 된다. 인스턴스에 의한 프로토타입 교체 인스턴스의 proto접근자 프로퍼티로 접근해서 프로토타입을 교체할 수 있다. Object.setPrototpyeOf(인스턴스, 프로토타입 객체)를 사용해서 프로토타입을 교체할 수 있다.단, 생성자 함수에 의한 교체와의 차이는 생성자 함수의 경우 생성자 함수의 prototype 프로퍼티에 교체한 프로토타입이 연결이 되어있지만, 인스턴스에 의한 교체는 생성자 함수의 prototype과 연결되어 있지 않다. proto 스펙이 아니라서 사용 가능성이 명확하지 않기 때문에 가능하면 Object.setPrototypeOf()를 사용하는 것을 추천한다. 생성자 함수에 의한 프로토타입 교체와 인스턴스에 의한 프로토타입 교체 비교프로토타입을 생성하면 생성자함수와 프로토타입 객체와 링크가 끊어져서 연결해줄 필요가 있다.생성자 함수에 prototype 프로퍼티의 참조를 연결해야하고, 프로토타입 객체는 constructor 프로퍼티에 생성자 함수 참조를 연결해야한다.이때, 생성자 함수로 교체하는 경우는 prototype 프로퍼티의 참조가 연결되었어 constructor 프로퍼티만 연결하면 되기 때문에 생성자 함수로 교체하는 것이 더 편리하다. instanceof 연산자instanceof 연산자는 이항 연산자로 좌항에 객체를 가르키는 식별자, 우항에는 생성자 함수를 가르키는 식별자를 피연산자로 받으며 좌항의 객체가 우항의 생성자 함수와 연결이 되어있는지를 boolean 값으로 평가하는 연산자이다.피연산자로 사용한 생성자 함수의 prototype 참조값이 해당 피연산자 객체의 프로토타입 체인상에 프로토타입 객체를 참조하고 있으면 true 값으로 평가된다.상속 관계를 고려한다. 직접 상속 Object.create 메소드Object.create(프로토타입 객체[, 프로퍼티 키 : {프로퍼티 디스크립터 객체},…]) 메소드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다.Object.create 메소드는 new 연산자 없이 객체를 생성할 수 있고, 프로토타입을 직접 지정하면서 객체를 생성할 수 있으며, 객체 리터럴에 의해 생성된 객체에 특정 객체를 상속받을 수 있다.단, 프로토타입을 null로 지정할 경우 프로토타입이 없는 객체가 생성되고 해당 객체는 프로토타입 체인의 최상위 객체가 되며 Object.prototype 객체의 빌트인 함수를 사용할 수 없게 된다. 객체 리터널 내부에서 proto접근자 프로퍼티를 사용한 직접 상속객체 리터널 내부에서 proto접근자 프로퍼티에 프로토타입으로 지정할 객체를 재할당하는 것이다. 정적 프로퍼티/메소드정적 프로퍼티/메소드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출 할 수 있는 프로퍼티/메소드를 말한다.모든 객체는 정적 프로퍼티와 메소드를 가질 수 있다. 생성자 함수도 함수 객체임으로 정적 프로퍼티/메소드를 갖을 수 있다.단, 해당 프로퍼티와 메소드를 참조 및 호출 하기 위해서는 해당 객체의 프로토타입 체인 상에 존재해야한다. 정적 메소드와 프로토타입 메소드 구별메소드 내부에 this를 통한 인스턴스를 참조하지 않을 때는 프로토타입 메소드 보다는 정적 메소드로 정의하는 것이 낫다.따라서, 메소드 내부에 this가 있어 인스턴스의 프로퍼티를 참조해야하는 경우는 프로토타입 메소드, 아닐 때는 정적메소드로 정의하는 것이 좋다.참조 문서에서 Object(/String/Number/Boolean).’메소드 이름’ 인 경우는 정적 메소드이고 Object.prototype.’메소드 이름’ 인 경우는 프로토타입 메소드이다.문서에서 프로토타입 메소드의 경우 ‘Object#메소드 이름’으로 표기하는 경우도 있다. 프로퍼티 존재 확인 inin 연산자를 사용하여 확인하여 boolean 값으로 평가한다. in 연산자는 이항 연산자로 좌항에는 프로퍼티 키를 나타내는 문자열을, 우항에는 객체로 평가되는 표현식을 피연산자로 받는다.in 연산자는 해당 객체 안에서 뿐만아니라 프로토타입 체인 상에 존재하는 모든 프로퍼티를 검색한다. Object.prototype.hasOwnProperty()in 연산자와 다르게 상속 받은 프로퍼티가 아닌 객체가 갖고 있는 프로퍼티만 검색하여 boolean 값으로 평가한다. 프로퍼티 열거 for…in 문for (변수선언문 in 객체) { }의 문법을 가지며 해당 객체의 모든 프로퍼티를 검색한다.당연히 in 연산자로 검색하기 때문에 상속 받은 프로퍼티도 전부 검색한다.단, [[Enumerable]]의 값이 false 값인 프로퍼티는 검색하지 않는다. 또한 프로퍼티 키가 심볼인 경우 검색하지 않는다. 만약 상속받은 프로퍼티를 제외하고 자신의 프로퍼티를 검색하려면 for의 블록문에 Object.prototype의 hasOwnProperty메소드를 사용하여 객체 자신의 프로퍼티인지 확인하는 조건식을 만들면 된다.주의점은, 일반적으로 for…in 문은 열거시 프로퍼티 순서를 고려하지 않는다. 하지만 모던 브라우저의 경우에 숫자인 프로퍼티 키에 대해서는 순서를 고려한다.배열의 경우는 일반적인 for문이나 for…of 문, Array.prototype.forEach 메소드를 사용하기를 권장한다. Object.keys/values/entries 메소드for…in 문이 상속된 프로퍼티도 검색하기에 for…in 문 보다 Object.keys/values/entries 메소드를 사용하기 권장한다. Object.keys 메소드열거 가능한 객체 자신의 프로퍼티 키를 배열로 반환한다. Object.values 메소드(ES8)열거 가능한 객체 자신의 프로퍼티 값을 배열로 반환한다. Object.entries 메소드(ES8)열거 가능한 객체 자신의 프로퍼티 키와 값을 배열로 묶어 그 값을 배열로 다시 묶은 값으로 반환한다.","link":"/2020/03/07/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/"},{"title":"표현식과 문","text":"1. 값이란?식(표현식)이 평가되어 만들어진 결과. 2. 리터럴이란?사람을 기준으로 만들어진 문자, 숫자, 기호, 등으로 사용된 것을 평가해서 동일한 값을 생성할 수 있는 표기 방식코드가 실행되는 시점(런타임,runtime)에 리터럴을 평가하여 값으로 만든다.리터럴을 평가하면 값이 나온다. 따라서 리터럴도 표현식이다. 3. 표현식이란?평가하여 결과로 값이 나오는 문.값으로 평가되는 것은 모두 표현식!!표현식인지 확인하는 방법은 변수에 할당해보면 된다. 4. 문이란?프로그램을 구성하는 기본 단위. 토큰으로 이루어져있다.최소 실행 단위이며 컴퓨터에게 보내는 명령이다.따라서, 문은 선언문, 할당문, 조건문, 반복문으로 구분 가능하다.문에는 세미콜론으로 종료를 나타낸다. 하지만 안써도 돌아가는 이유는 자바스크립트 엔진이 문의 끝이라고 생각하는 부분에 자동적으로 만든다. 5. 토큰이란?문을 구성하는 코드의 기본 요소이다. 키워드, 식별자, 연산자, 리터럴, 세미콜론, 마침표가 들어간다. 6. 완료값이란?브라우저(크롬)안에서 표현식이 아닌 문을 입력하면 undefined를 출력한다.이것을 완료값이라고 한다.","link":"/2020/02/20/%ED%91%9C%ED%98%84%EC%8B%9D%EA%B3%BC-%EB%AC%B8/"},{"title":"클래스","text":"클래스ES6부터 도입된 클래스 기반 프로그래밍 언어와 유사한 새로운 객체 생성 메커니즘이니다.class 키워드를 사용하여 정의하며, 생성자 함수로 마찬가지로 파스칼 케이스를 사용하는 것이 일반적이다. 12// 클래스 선언문class Obj {} 함수와 마찬가지로 클래스도 일급 객체임으로 표현식으로 정의할 수도 있다. 12// 클래스 표현식const obj = class Obj {} 클래스의 특징 클래스 호이스팅클래스는 정의 이전에 참조할 수 없다.참조시, ReferenceError를 출력한다. let, const 처럼 작동한다. 생성자 함수로 평가클래스는 함수로 평가된다.인스턴스를 생성하기 위해서 반드시 new 연산자와 함께 사용해야한다.new 연산자를 사용하지 않고 호출 했을 시, TypeError를 출력한다. 클래스에서 정의하는 메소드일반적으로 클래스 몸체에 0개 이상의 메소드만을 선언할 수 있다.정의할 수 있는 메소드는 3가지가 있다. constructor(생성자)인스턴스를 생성하고 초기화하기 위한 메소드이다. 클래스 안에서 없거나 단 한개만 정의해야 한다.2개 이상 정의할 시 syntaxError를 출력한다.생략하면 암묵적으로 디폴트 constructor가 정의된다. 해당 메소드 안에 this는 생성할 객체를 가르킨다. constructor 메소드 몸체 안에 return문을 쓰면 반환할 값이 객체일 때는 해당 객체를 반환하며 원시값이면 무시한다.하지만 this가 아닌 다른 값을 반환하는 것은 클래스의 기본동작을 훼손하기 때문에 return 문은 반드시 생략해야한다. 프로토타입 메소드클래스 몸체에 정의한 메소드(메소드 축약 표현)는 생성할 인스턴스 객체의 프로토타입 객체의 메소드로 추가된다. 정적 메소드클래스 몸체에 strtic 키워드를 사용하고 메소드를 정의하면 정적 메소드로 해당 class의 메소드가 된다. 클래스에서 정의하는 메소드의 특징 function 키워드를 생략한 메소드 축약 표현을 사용한다. 정의할 때 콤마(;)가 필요없다. 암묵적으로 strict 모드로 실행된다. 열거할 수 없다. [[Enumerable]]값이 false이다. [[Construct]]를 갖지 않는 non-costructor 함수이다. 클래스에 의한 인스턴스 생성과정 인스턴스 생성과 this 바인딩new 연산자와 함께 클래스를 호출하면 constructor 메소드의 내부 코드가 실행되고 우선 암묵적으로 빈 객체를 만들며 이 객체를 this에 바인딩한다. 인스턴스 초기화this에 바인딩 되있는 객체에 프로퍼티를 추가한다. 클래스를 호출시 입력했던 인수를 constructor 매개변수에 전달하여 받은 값으로 인스턴스의 프로퍼티 값을 초기화한다. 프로토타입 / 정적 메소드 추가프로토타입 메소드는 생성될 인스턴스의 프로토타입 객체에 추가하며, 정적 메소드는 해당 클래스에 추가된다. 인스턴스 반환this에 바인딩된 객체를 반환한다. 프로퍼티 정의인스턴스의 프로퍼티는 constructor 메소드 내부에서 생성자함수 처럼 프로퍼티 동적 생성을 통해 생성한다.접근자 프로퍼티도 정의할 수 있다. 클래스 필드 정의(제안)클래스 필드란 클래스 기반 객체 지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가르키는 용어이다.자바스크립트는 원래 constructor 안에서 프로퍼티 동적 생성을 통해서만 프로퍼티를 생성할 수 있다. 클래스 몸체에서 정의하려고 하면 SyntaxError를 출력한다. 하지만, 현재(2020.03)에 클래스 필드 정의를 의미하는 “Class field declarations”가 stage 3에 제안 되어있다.최신 버전의 브라우저와 node.js에서는 클래스 필드 정의를 할 시 오류를 출력하지 않는다. 클래스 필드 정의를 사용하여 프로퍼티를 정의할 때 this는 constructor 메소드 안에서만 유효함으로 this를 사용하면 안된다. 하지만 해당 프로퍼티를 참조하는 경우에는 반드시 this를 사용해야한다. 클래스 필드에 초기값을 할당하지 않으면 undefined를 갖는다.하지만 후에 초기화를 해주어야한다면 constructor 메소드에서 할당을 해주어야하기 때문에 클래스 필드 정의를 할 필요가 없다. 클래스 필드에 함수를 할당하면 프로토타입 메소드가 아닌 인스턴스의 메소드가 된다. private 필드 정의(제안)자바스크립트에는 클로저의 개념을 사용해서 다른 객체 지향 언어의 private 키워드의 기능을 흉내낼 수 있다.차이는 private된 변수에 접근하면 에러가 아닌 undefined가 반환된다.하지만, private 필드 정의도 클래스 필드 정의와 마찬가지로 제안 되어있다.private 필드 정의는 해당 필드 정의 선두에 ‘#’를 붙여주면 된다.이렇게 되면 해당 클래스 필드는 클래스 내부에서만 참조가능하다.(접근자 프로퍼티로 접근하는 것은 제외) static 필드 정의(제안)정적 프로퍼티도 클래스 필드 앞에 static 키워드를 사용하여 정의하면 가능하다. 상속에 의한 클래스 확장기존의 클래스를 상속받아 새로운 클래스를 만들 수 있다. extends 키워드를 통해 클래스 상속을 통해 다른 클래스를 확장할 수 있다.상속을 통해 확장된 클래스를 서브 클래스라고 부르고 서브 클래스에게 상속된 클래스를 수퍼 클래스라고 한다.서브 클래스는 파생 클래스 또는 자식 클래스, 수퍼 클래스는 베이스 클래스 또는 부모 클래스라고 한다. extends 키워트class ‘서브 클래스’ extands ‘수퍼 클래스[또는 생성자 함수]’ {} 의 형식으로 사용한다. super 키워드super 키워드는 서브 클래스에서 수퍼 클래스를 호출하거나 참조할 때 사용된다. super 호출호출하면 수퍼 클래스의 constructor를 호출한다. super 참조참조하여 수퍼 클래스의 프로토타입 메소드를 호출할 수 있다. super 키워드 사용시 주의사항 호출할 시 서브 클래스에서 constructor를 생략하지 않은 경우, 서부 클래스의 constructor에서 반드시 super 키워드로 호출해주어야 한다. 서브 클래스에서 super 호출 전에 this를 참조할 수 없다. super 키워드는 반드시 서브 클래스 constructor에서만 호출해야 한다. 참조할 시 서브 클래스의 프로토타입 메소드 안에서 참조할 시, 수퍼 클래스의 프로토타입를 가르킨다.서브 클래스는 확장될 때 내부 슬롯[[HomeObject]]에 바인딩되어있는 프로토타입 객체를 기억한다.주의점은, 메소드 축약 표현으로 정의된 메소드만 [[HomeObject]]를 갖는다. 서브 클래스의 정적 메소드 안에서 참조할 시, 수퍼 클래스의 정적 메소드를 가르킨다. 상속 클래스의 인스턴스 생성과정new 연산자로 서브 클래스를 호출하면 서브 클래스 constructor 메소드 실행 전에 인스턴스 생성을 수퍼 클래스에게 위임.서브 클래스에서 빈 객체인 인스턴스를 만드는 것 대신, super 키워드를 호출하여 인스턴스 생성을 수퍼 클래스에게 위임한다.때문에, 암묵적 생성시에는 자동적으로 super 키워드를 호출하지만 아닐 경우에는 반드시 super 키워드를 호출해야 한다. 수퍼 클래스의 인스턴스 생성과 this 바인딩수퍼 클래스가 실행되기 전에 암묵적 빈 객체인 인스턴스를 생성, 이 인스턴스를 this에 바인딩한다. 수퍼 클래스의 인스턴스 초기화인스턴스에 프로퍼티를 추가하고 서브 클래스가 받은 인수로 인스턴스를 초기화한다. 수퍼 클래스의 프로토타입/ 정적 메소드 추가이 과정까지가 super 키워드가 호출되어 실행된 결과이다. 서브 클래스 constructor로 복귀 및 this에 수퍼 클래스에서 만든 인스턴스를 바인딩 서브 클래스의 인스턴스 초기화 서브 클래스의 프로토타입/ 정적 메소드 추가 인스턴스 반환","link":"/2020/03/18/%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"title":"함수와 일급객체","text":"일급 객체특정조건을 만족하는 객체를 일급 객체라고 한다. 무명의 리터럴로 생성 가능. 변수나 자료구조 객체에 저장 가능. 함수의 매개 변수에 전달 가능. 함수의 결과값으로 반환 가능. 함수는 일급객체이다. 이 말은 함수를 객체처럼 사용할 수 있다는 것이다. 함수 객체의 프로퍼티 arguments 프로퍼티함수 호출시 전달된 인수를 argument라고 하고 이 인수들의 정보를 객체로 담고 있는 유사배열 객체를 값으로 갖는 프로퍼티이다.argument 객체는 함수 내부에서 지역 변수 처럼 사용가능하다. caller 프로퍼티함수 자신을 호출하는 메소드를 말한다.ECMAScript 스펙에 포함되지 않았다. length 프로퍼티함수 정의시 선언한 매개변수의 수를 값으로 갖는 프로퍼티이다. name 프로퍼티함수 객체의 이름을 값으로 갖는 프로퍼티이다.ES6 이후 표준으로 들어왔다.익명함수의 경우 빈 문자열을 값으로 갖는다. proto접근자 프로퍼티[[prototype]] 내부 슬롯에 접근하는 접근자 프로퍼티이다. 프로토타입 객체에 접근할 수 있다. prototype 프로퍼티함수만이 갖는 프로퍼티로 함수의 프로토타입 객체를 가르킨다. 프로토타입 객체가 무엇인지 확인할 수 있다.","link":"/2020/03/06/%ED%95%A8%EC%88%98%EC%99%80-%EC%9D%BC%EA%B8%89%EA%B0%9D%EC%B2%B4/"},{"title":"프로퍼티 어트리뷰트","text":"내부 슬롯과 내부 메소드자바스크립트에서 객체를 만들 때 해당 객체를 컨드롤 하기 위해 만드는 프로퍼티와 메소드가 있는데 프로퍼티를 내부 슬롯(internal slot), 메소드를 내부 메소드(internal method)라고 한다.원칙적으로는 내부 슬롯과 내부 메소드에 접근할 수 없지만 몇몇 내부 슬롯과 내부 메소드에 한하여 간접적으로 접근 가능하다. 프로퍼티 상태와 프로퍼티 어트리뷰트, 디스크립터 객체 프로퍼티 상태란?자바스크립트에서 프로퍼티를 생성할 때 해당 프로퍼티에 대한 환경 설정 정보들을 프로퍼티 상태라고 한다.프로퍼티 상태에는 프로퍼티 값(value) 값의 갱신 여부(writable) 열거 가능 여부(enumerable) 재정의 가능 여부(configurable)가 있다. 프로퍼티 어트리뷰트란?자바스크립트에서 관리하는 프로퍼티 상태에 접근할 수 있는 내부 슬롯이다. 디스크립터 객체란?어떠한 객체나 프로퍼티등의 어트리뷰트 정보를 제공하는 객체이다.기본적으로 프로퍼티의 경우, Object.OwnPropertyDesctriptor 메소드를 이용해 프로퍼티의 상태를 확인할 수 있다.존재하지 않는 프로퍼티나 상속받은 프로퍼티에 대한 디스크립터 객체를 요구할 경우 undefined 값을 반환한다. 프로퍼티의 종류프로퍼티는 데이터 프로퍼티와 접근자 프로퍼티로 나누어진다. 데이터 프로퍼티키와 값으로 구성된 일반적인 프로퍼티.데이터 프로퍼티는 해당 프로퍼티 어트리뷰트를 갖는다. [[Value]] : 프로퍼티 값 [[Writable]] : 값 갱신 여부false인 경우 값을 변경할 수 없다. 만약 false일 때, 값을 변경을 하면 에러 없이 무시된다. [[Enumerable]] : 열거 가능 여부for…in 문이나 Object.keys 등으로 열거 가능 여부를 정의한다. [[Configurable]] : 삭제,재정의 가능 여부delete, Object.defineProperty 메소드를 사용해 프로퍼티 삭제, 어트리뷰트 재정의 가능 여부를 정의한다.false인 경우 삭제와 어트리뷰트 재정의를 할 수 없다. 이 때, 어트리뷰트 재정의를 할 경우 에러가 발생하지만 삭제의 경우는 에러 없이 무시된다. 접근자 프로퍼티다른 데이터 프로퍼티 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티. 프로퍼티 이름 앞에 get이나 set으로 구분할 수 있다.데이터 프로퍼티 어트리뷰트와 다르게 [[Value]], [[Writable]] 대신에 [[Get]], [[Set]] 프로퍼티 어트리뷰트를 갖는다. [[Get]]접근자 프로퍼티의 값에 접근하면 호출되는 getter함수. 다른 데이터 프로퍼티를 가져와 함수를 연산을 시킬수 있다. [[Set]]접근자 프로퍼티를 통해 다른 데이터 프로퍼티 값을 저장/수정할 때 호출되는 setter함수. 다른 데이터 프로퍼티를 한꺼번에 수정할 수 있다. 12345678910111213141516171819const obj = { // 데이터 프로퍼티 name : 'obj', number : '1', // getter 함수 get objNum() { return `${this.number}.${this.name}`; } // setter 함수 set objNum(value) { [this.number, this.name] = value.split('.'); }};console.log(obj); // {name: \"obj\", number: \"1\"number // [[get]] 어트리뷰트에 접근conso1lg(obj.objNum); // obj.1console.log(obj); // {name: \"object\", number: \"1\"} 프로퍼티 정의새로운 프로퍼티를 추가할 때 프로퍼티 어트리뷰트를 명시적으로 정의하거나 기존 프로퍼티의 어트리뷰트를 재정의 하는 것이다.Object.defineProperty 메소드와 Object.defineProperties 메소드를 사용해서 프로퍼티 어트리뷰트를 정의할 수 있다. 12345678910111213141516171819202122232425262728293031323334const obj = {};// 데이터 프로퍼티 정의Object.defineProperty(obj,'name',{ value: 'obj', writable: true, enumerable: true, configurable: true});Object.defineProperty(obj,'number',{ value: '1'}); // 프로퍼티 어트리뷰트를 정의해주지 않으면 undefined, false이 기본값이다.// 접근자 프로퍼티 정의Object.defineProperty(obj,'objNum',{ get() { return `${this.number}.${this.name}`; }, set(value) { [this.number, this.name] = value.split('.'); }, enumerable: true, configurable: true});// 다수의 프로퍼티 재정의Object.defineProperties(obj, { name: { writable: false }, number: { writable: false }}); 객체 변경 방지 객체 확장 금지Object.preventExtensions 메소드를 사용하여 객체의 확장을 금지한다.프로퍼티 추가만 금지한다. 객체 밀봉Object.seal 메소드를 사용하여 객체를 밀봉한다.읽기와 쓰기만 가능하다. 프로퍼티 추가/삭제, 어프리뷰트 재정의를 금지한다. 객체 동결Object.freeze 메소드를 사용하여 객체를 동결시킨다.읽기만 가능하다. 프로퍼티 갱신, 추가/삭제, 어트리뷰트 재정의를 금지한다. 불변 객체Object.freeze 메소드를 사용하여 모든 프로퍼티를 동결시킨다.이렇게 구현하면 중첩 객체도 동결이 된다.","link":"/2020/03/05/%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/"}],"tags":[{"name":"컴퓨터_기초","slug":"컴퓨터-기초","link":"/tags/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B8%B0%EC%B4%88/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"변수","slug":"변수","link":"/tags/%EB%B3%80%EC%88%98/"},{"name":"var","slug":"var","link":"/tags/var/"},{"name":"let","slug":"let","link":"/tags/let/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"상수","slug":"상수","link":"/tags/%EC%83%81%EC%88%98/"},{"name":"블록_레벨_스코프","slug":"블록-레벨-스코프","link":"/tags/%EB%B8%94%EB%A1%9D-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84/"},{"name":"개념_정리","slug":"개념-정리","link":"/tags/%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/"},{"name":"컴퓨터_심화","slug":"컴퓨터-심화","link":"/tags/%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%8B%AC%ED%99%94/"},{"name":"함수","slug":"함수","link":"/tags/%ED%95%A8%EC%88%98/"},{"name":"화살표 함수","slug":"화살표-함수","link":"/tags/%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"객체","slug":"객체","link":"/tags/%EA%B0%9D%EC%B2%B4/"},{"name":"전역_객체","slug":"전역-객체","link":"/tags/%EC%A0%84%EC%97%AD-%EA%B0%9D%EC%B2%B4/"},{"name":"빌트인_객체","slug":"빌트인-객체","link":"/tags/%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EA%B0%9D%EC%B2%B4/"},{"name":"레퍼_객체","slug":"레퍼-객체","link":"/tags/%EB%A0%88%ED%8D%BC-%EA%B0%9D%EC%B2%B4/"},{"name":"리터럴","slug":"리터럴","link":"/tags/%EB%A6%AC%ED%84%B0%EB%9F%B4/"},{"name":"프로퍼티","slug":"프로퍼티","link":"/tags/%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0/"},{"name":"함수_호출","slug":"함수-호출","link":"/tags/%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"this_바인딩","slug":"this-바인딩","link":"/tags/this-%EB%B0%94%EC%9D%B8%EB%94%A9/"},{"name":"배열","slug":"배열","link":"/tags/%EB%B0%B0%EC%97%B4/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"Array_메소드","slug":"Array-메소드","link":"/tags/Array-%EB%A9%94%EC%86%8C%EB%93%9C/"},{"name":"데이터_타입","slug":"데이터-타입","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85/"},{"name":"동적_타입_언어","slug":"동적-타입-언어","link":"/tags/%EB%8F%99%EC%A0%81-%ED%83%80%EC%9E%85-%EC%96%B8%EC%96%B4/"},{"name":"정적_타입_언어","slug":"정적-타입-언어","link":"/tags/%EC%A0%95%EC%A0%81-%ED%83%80%EC%9E%85-%EC%96%B8%EC%96%B4/"},{"name":"생성자_함수","slug":"생성자-함수","link":"/tags/%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98/"},{"name":"인스턴스","slug":"인스턴스","link":"/tags/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4/"},{"name":"스코프","slug":"스코프","link":"/tags/%EC%8A%A4%EC%BD%94%ED%94%84/"},{"name":"전역_변수","slug":"전역-변수","link":"/tags/%EC%A0%84%EC%97%AD-%EB%B3%80%EC%88%98/"},{"name":"지역_변수","slug":"지역-변수","link":"/tags/%EC%A7%80%EC%97%AD-%EB%B3%80%EC%88%98/"},{"name":"스프레드 문법","slug":"스프레드-문법","link":"/tags/%EC%8A%A4%ED%94%84%EB%A0%88%EB%93%9C-%EB%AC%B8%EB%B2%95/"},{"name":"값","slug":"값","link":"/tags/%EA%B0%92/"},{"name":"인수","slug":"인수","link":"/tags/%EC%9D%B8%EC%88%98/"},{"name":"연산자","slug":"연산자","link":"/tags/%EC%97%B0%EC%82%B0%EC%9E%90/"},{"name":"부수_효과","slug":"부수-효과","link":"/tags/%EB%B6%80%EC%88%98-%ED%9A%A8%EA%B3%BC/"},{"name":"전역_스코프","slug":"전역-스코프","link":"/tags/%EC%A0%84%EC%97%AD-%EC%8A%A4%EC%BD%94%ED%94%84/"},{"name":"지역_스코프","slug":"지역-스코프","link":"/tags/%EC%A7%80%EC%97%AD-%EC%8A%A4%EC%BD%94%ED%94%84/"},{"name":"실행_컨텍스트","slug":"실행-컨텍스트","link":"/tags/%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"},{"name":"렉시컬_환경","slug":"렉시컬-환경","link":"/tags/%EB%A0%89%EC%8B%9C%EC%BB%AC-%ED%99%98%EA%B2%BD/"},{"name":"원시_값","slug":"원시-값","link":"/tags/%EC%9B%90%EC%8B%9C-%EA%B0%92/"},{"name":"엄격_모드","slug":"엄격-모드","link":"/tags/%EC%97%84%EA%B2%A9-%EB%AA%A8%EB%93%9C/"},{"name":"제어문","slug":"제어문","link":"/tags/%EC%A0%9C%EC%96%B4%EB%AC%B8/"},{"name":"조건문","slug":"조건문","link":"/tags/%EC%A1%B0%EA%B1%B4%EB%AC%B8/"},{"name":"반복문","slug":"반복문","link":"/tags/%EB%B0%98%EB%B3%B5%EB%AC%B8/"},{"name":"타입_변환","slug":"타입-변환","link":"/tags/%ED%83%80%EC%9E%85-%EB%B3%80%ED%99%98/"},{"name":"단축평가","slug":"단축평가","link":"/tags/%EB%8B%A8%EC%B6%95%ED%8F%89%EA%B0%80/"},{"name":"함수_리터럴","slug":"함수-리터럴","link":"/tags/%ED%95%A8%EC%88%98-%EB%A6%AC%ED%84%B0%EB%9F%B4/"},{"name":"함수_정의","slug":"함수-정의","link":"/tags/%ED%95%A8%EC%88%98-%EC%A0%95%EC%9D%98/"},{"name":"함수_종류","slug":"함수-종류","link":"/tags/%ED%95%A8%EC%88%98-%EC%A2%85%EB%A5%98/"},{"name":"렉시컬스코프","slug":"렉시컬스코프","link":"/tags/%EB%A0%89%EC%8B%9C%EC%BB%AC%EC%8A%A4%EC%BD%94%ED%94%84/"},{"name":"클로저","slug":"클로저","link":"/tags/%ED%81%B4%EB%A1%9C%EC%A0%80/"},{"name":"자유변수","slug":"자유변수","link":"/tags/%EC%9E%90%EC%9C%A0%EB%B3%80%EC%88%98/"},{"name":"프로토타입","slug":"프로토타입","link":"/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/"},{"name":"상속","slug":"상속","link":"/tags/%EC%83%81%EC%86%8D/"},{"name":"프로토타입_체인","slug":"프로토타입-체인","link":"/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8/"},{"name":"캡슐화","slug":"캡슐화","link":"/tags/%EC%BA%A1%EC%8A%90%ED%99%94/"},{"name":"클래스","slug":"클래스","link":"/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"표현식","slug":"표현식","link":"/tags/%ED%91%9C%ED%98%84%EC%8B%9D/"},{"name":"문","slug":"문","link":"/tags/%EB%AC%B8/"},{"name":"super","slug":"super","link":"/tags/super/"},{"name":"객체_생성","slug":"객체-생성","link":"/tags/%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1/"},{"name":"일급객체","slug":"일급객체","link":"/tags/%EC%9D%BC%EA%B8%89%EA%B0%9D%EC%B2%B4/"},{"name":"내부_슬롯","slug":"내부-슬롯","link":"/tags/%EB%82%B4%EB%B6%80-%EC%8A%AC%EB%A1%AF/"},{"name":"내부_메소드","slug":"내부-메소드","link":"/tags/%EB%82%B4%EB%B6%80-%EB%A9%94%EC%86%8C%EB%93%9C/"},{"name":"어트리뷰트","slug":"어트리뷰트","link":"/tags/%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/"}],"categories":[]}